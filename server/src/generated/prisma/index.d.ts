// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  dailyExercise: (where?: DailyExerciseWhereInput) => Promise<boolean>;
  exercise: (where?: ExerciseWhereInput) => Promise<boolean>;
  exerciseParameter: (where?: ExerciseParameterWhereInput) => Promise<boolean>;
  exerciseRoutine: (where?: ExerciseRoutineWhereInput) => Promise<boolean>;
  exerciseType: (where?: ExerciseTypeWhereInput) => Promise<boolean>;
  measurement: (where?: MeasurementWhereInput) => Promise<boolean>;
  routine: (where?: RoutineWhereInput) => Promise<boolean>;
  routineWorkoutPlan: (
    where?: RoutineWorkoutPlanWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userMeasurement: (where?: UserMeasurementWhereInput) => Promise<boolean>;
  workout: (where?: WorkoutWhereInput) => Promise<boolean>;
  workoutExercise: (where?: WorkoutExerciseWhereInput) => Promise<boolean>;
  workoutParameter: (where?: WorkoutParameterWhereInput) => Promise<boolean>;
  workoutPlan: (where?: WorkoutPlanWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  dailyExercise: (
    where: DailyExerciseWhereUniqueInput
  ) => DailyExerciseNullablePromise;
  dailyExercises: (args?: {
    where?: DailyExerciseWhereInput;
    orderBy?: DailyExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DailyExercise>;
  dailyExercisesConnection: (args?: {
    where?: DailyExerciseWhereInput;
    orderBy?: DailyExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DailyExerciseConnectionPromise;
  exercise: (where: ExerciseWhereUniqueInput) => ExerciseNullablePromise;
  exercises: (args?: {
    where?: ExerciseWhereInput;
    orderBy?: ExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Exercise>;
  exercisesConnection: (args?: {
    where?: ExerciseWhereInput;
    orderBy?: ExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExerciseConnectionPromise;
  exerciseParameter: (
    where: ExerciseParameterWhereUniqueInput
  ) => ExerciseParameterNullablePromise;
  exerciseParameters: (args?: {
    where?: ExerciseParameterWhereInput;
    orderBy?: ExerciseParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExerciseParameter>;
  exerciseParametersConnection: (args?: {
    where?: ExerciseParameterWhereInput;
    orderBy?: ExerciseParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExerciseParameterConnectionPromise;
  exerciseRoutine: (
    where: ExerciseRoutineWhereUniqueInput
  ) => ExerciseRoutineNullablePromise;
  exerciseRoutines: (args?: {
    where?: ExerciseRoutineWhereInput;
    orderBy?: ExerciseRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExerciseRoutine>;
  exerciseRoutinesConnection: (args?: {
    where?: ExerciseRoutineWhereInput;
    orderBy?: ExerciseRoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExerciseRoutineConnectionPromise;
  exerciseType: (
    where: ExerciseTypeWhereUniqueInput
  ) => ExerciseTypeNullablePromise;
  exerciseTypes: (args?: {
    where?: ExerciseTypeWhereInput;
    orderBy?: ExerciseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExerciseType>;
  exerciseTypesConnection: (args?: {
    where?: ExerciseTypeWhereInput;
    orderBy?: ExerciseTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExerciseTypeConnectionPromise;
  measurement: (
    where: MeasurementWhereUniqueInput
  ) => MeasurementNullablePromise;
  measurements: (args?: {
    where?: MeasurementWhereInput;
    orderBy?: MeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Measurement>;
  measurementsConnection: (args?: {
    where?: MeasurementWhereInput;
    orderBy?: MeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementConnectionPromise;
  routine: (where: RoutineWhereUniqueInput) => RoutineNullablePromise;
  routines: (args?: {
    where?: RoutineWhereInput;
    orderBy?: RoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Routine>;
  routinesConnection: (args?: {
    where?: RoutineWhereInput;
    orderBy?: RoutineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoutineConnectionPromise;
  routineWorkoutPlan: (
    where: RoutineWorkoutPlanWhereUniqueInput
  ) => RoutineWorkoutPlanNullablePromise;
  routineWorkoutPlans: (args?: {
    where?: RoutineWorkoutPlanWhereInput;
    orderBy?: RoutineWorkoutPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RoutineWorkoutPlan>;
  routineWorkoutPlansConnection: (args?: {
    where?: RoutineWorkoutPlanWhereInput;
    orderBy?: RoutineWorkoutPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoutineWorkoutPlanConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userMeasurement: (
    where: UserMeasurementWhereUniqueInput
  ) => UserMeasurementNullablePromise;
  userMeasurements: (args?: {
    where?: UserMeasurementWhereInput;
    orderBy?: UserMeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserMeasurement>;
  userMeasurementsConnection: (args?: {
    where?: UserMeasurementWhereInput;
    orderBy?: UserMeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserMeasurementConnectionPromise;
  workout: (where: WorkoutWhereUniqueInput) => WorkoutNullablePromise;
  workouts: (args?: {
    where?: WorkoutWhereInput;
    orderBy?: WorkoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Workout>;
  workoutsConnection: (args?: {
    where?: WorkoutWhereInput;
    orderBy?: WorkoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkoutConnectionPromise;
  workoutExercise: (
    where: WorkoutExerciseWhereUniqueInput
  ) => WorkoutExerciseNullablePromise;
  workoutExercises: (args?: {
    where?: WorkoutExerciseWhereInput;
    orderBy?: WorkoutExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WorkoutExercise>;
  workoutExercisesConnection: (args?: {
    where?: WorkoutExerciseWhereInput;
    orderBy?: WorkoutExerciseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkoutExerciseConnectionPromise;
  workoutParameter: (
    where: WorkoutParameterWhereUniqueInput
  ) => WorkoutParameterNullablePromise;
  workoutParameters: (args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WorkoutParameter>;
  workoutParametersConnection: (args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkoutParameterConnectionPromise;
  workoutPlan: (
    where: WorkoutPlanWhereUniqueInput
  ) => WorkoutPlanNullablePromise;
  workoutPlans: (args?: {
    where?: WorkoutPlanWhereInput;
    orderBy?: WorkoutPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WorkoutPlan>;
  workoutPlansConnection: (args?: {
    where?: WorkoutPlanWhereInput;
    orderBy?: WorkoutPlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkoutPlanConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDailyExercise: (data: DailyExerciseCreateInput) => DailyExercisePromise;
  updateDailyExercise: (args: {
    data: DailyExerciseUpdateInput;
    where: DailyExerciseWhereUniqueInput;
  }) => DailyExercisePromise;
  updateManyDailyExercises: (args: {
    data: DailyExerciseUpdateManyMutationInput;
    where?: DailyExerciseWhereInput;
  }) => BatchPayloadPromise;
  upsertDailyExercise: (args: {
    where: DailyExerciseWhereUniqueInput;
    create: DailyExerciseCreateInput;
    update: DailyExerciseUpdateInput;
  }) => DailyExercisePromise;
  deleteDailyExercise: (
    where: DailyExerciseWhereUniqueInput
  ) => DailyExercisePromise;
  deleteManyDailyExercises: (
    where?: DailyExerciseWhereInput
  ) => BatchPayloadPromise;
  createExercise: (data: ExerciseCreateInput) => ExercisePromise;
  updateExercise: (args: {
    data: ExerciseUpdateInput;
    where: ExerciseWhereUniqueInput;
  }) => ExercisePromise;
  updateManyExercises: (args: {
    data: ExerciseUpdateManyMutationInput;
    where?: ExerciseWhereInput;
  }) => BatchPayloadPromise;
  upsertExercise: (args: {
    where: ExerciseWhereUniqueInput;
    create: ExerciseCreateInput;
    update: ExerciseUpdateInput;
  }) => ExercisePromise;
  deleteExercise: (where: ExerciseWhereUniqueInput) => ExercisePromise;
  deleteManyExercises: (where?: ExerciseWhereInput) => BatchPayloadPromise;
  createExerciseParameter: (
    data: ExerciseParameterCreateInput
  ) => ExerciseParameterPromise;
  updateExerciseParameter: (args: {
    data: ExerciseParameterUpdateInput;
    where: ExerciseParameterWhereUniqueInput;
  }) => ExerciseParameterPromise;
  updateManyExerciseParameters: (args: {
    data: ExerciseParameterUpdateManyMutationInput;
    where?: ExerciseParameterWhereInput;
  }) => BatchPayloadPromise;
  upsertExerciseParameter: (args: {
    where: ExerciseParameterWhereUniqueInput;
    create: ExerciseParameterCreateInput;
    update: ExerciseParameterUpdateInput;
  }) => ExerciseParameterPromise;
  deleteExerciseParameter: (
    where: ExerciseParameterWhereUniqueInput
  ) => ExerciseParameterPromise;
  deleteManyExerciseParameters: (
    where?: ExerciseParameterWhereInput
  ) => BatchPayloadPromise;
  createExerciseRoutine: (
    data: ExerciseRoutineCreateInput
  ) => ExerciseRoutinePromise;
  updateExerciseRoutine: (args: {
    data: ExerciseRoutineUpdateInput;
    where: ExerciseRoutineWhereUniqueInput;
  }) => ExerciseRoutinePromise;
  updateManyExerciseRoutines: (args: {
    data: ExerciseRoutineUpdateManyMutationInput;
    where?: ExerciseRoutineWhereInput;
  }) => BatchPayloadPromise;
  upsertExerciseRoutine: (args: {
    where: ExerciseRoutineWhereUniqueInput;
    create: ExerciseRoutineCreateInput;
    update: ExerciseRoutineUpdateInput;
  }) => ExerciseRoutinePromise;
  deleteExerciseRoutine: (
    where: ExerciseRoutineWhereUniqueInput
  ) => ExerciseRoutinePromise;
  deleteManyExerciseRoutines: (
    where?: ExerciseRoutineWhereInput
  ) => BatchPayloadPromise;
  createExerciseType: (data: ExerciseTypeCreateInput) => ExerciseTypePromise;
  updateExerciseType: (args: {
    data: ExerciseTypeUpdateInput;
    where: ExerciseTypeWhereUniqueInput;
  }) => ExerciseTypePromise;
  updateManyExerciseTypes: (args: {
    data: ExerciseTypeUpdateManyMutationInput;
    where?: ExerciseTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertExerciseType: (args: {
    where: ExerciseTypeWhereUniqueInput;
    create: ExerciseTypeCreateInput;
    update: ExerciseTypeUpdateInput;
  }) => ExerciseTypePromise;
  deleteExerciseType: (
    where: ExerciseTypeWhereUniqueInput
  ) => ExerciseTypePromise;
  deleteManyExerciseTypes: (
    where?: ExerciseTypeWhereInput
  ) => BatchPayloadPromise;
  createMeasurement: (data: MeasurementCreateInput) => MeasurementPromise;
  updateMeasurement: (args: {
    data: MeasurementUpdateInput;
    where: MeasurementWhereUniqueInput;
  }) => MeasurementPromise;
  updateManyMeasurements: (args: {
    data: MeasurementUpdateManyMutationInput;
    where?: MeasurementWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurement: (args: {
    where: MeasurementWhereUniqueInput;
    create: MeasurementCreateInput;
    update: MeasurementUpdateInput;
  }) => MeasurementPromise;
  deleteMeasurement: (where: MeasurementWhereUniqueInput) => MeasurementPromise;
  deleteManyMeasurements: (
    where?: MeasurementWhereInput
  ) => BatchPayloadPromise;
  createRoutine: (data: RoutineCreateInput) => RoutinePromise;
  updateRoutine: (args: {
    data: RoutineUpdateInput;
    where: RoutineWhereUniqueInput;
  }) => RoutinePromise;
  updateManyRoutines: (args: {
    data: RoutineUpdateManyMutationInput;
    where?: RoutineWhereInput;
  }) => BatchPayloadPromise;
  upsertRoutine: (args: {
    where: RoutineWhereUniqueInput;
    create: RoutineCreateInput;
    update: RoutineUpdateInput;
  }) => RoutinePromise;
  deleteRoutine: (where: RoutineWhereUniqueInput) => RoutinePromise;
  deleteManyRoutines: (where?: RoutineWhereInput) => BatchPayloadPromise;
  createRoutineWorkoutPlan: (
    data: RoutineWorkoutPlanCreateInput
  ) => RoutineWorkoutPlanPromise;
  updateRoutineWorkoutPlan: (args: {
    data: RoutineWorkoutPlanUpdateInput;
    where: RoutineWorkoutPlanWhereUniqueInput;
  }) => RoutineWorkoutPlanPromise;
  updateManyRoutineWorkoutPlans: (args: {
    data: RoutineWorkoutPlanUpdateManyMutationInput;
    where?: RoutineWorkoutPlanWhereInput;
  }) => BatchPayloadPromise;
  upsertRoutineWorkoutPlan: (args: {
    where: RoutineWorkoutPlanWhereUniqueInput;
    create: RoutineWorkoutPlanCreateInput;
    update: RoutineWorkoutPlanUpdateInput;
  }) => RoutineWorkoutPlanPromise;
  deleteRoutineWorkoutPlan: (
    where: RoutineWorkoutPlanWhereUniqueInput
  ) => RoutineWorkoutPlanPromise;
  deleteManyRoutineWorkoutPlans: (
    where?: RoutineWorkoutPlanWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserMeasurement: (
    data: UserMeasurementCreateInput
  ) => UserMeasurementPromise;
  updateUserMeasurement: (args: {
    data: UserMeasurementUpdateInput;
    where: UserMeasurementWhereUniqueInput;
  }) => UserMeasurementPromise;
  updateManyUserMeasurements: (args: {
    data: UserMeasurementUpdateManyMutationInput;
    where?: UserMeasurementWhereInput;
  }) => BatchPayloadPromise;
  upsertUserMeasurement: (args: {
    where: UserMeasurementWhereUniqueInput;
    create: UserMeasurementCreateInput;
    update: UserMeasurementUpdateInput;
  }) => UserMeasurementPromise;
  deleteUserMeasurement: (
    where: UserMeasurementWhereUniqueInput
  ) => UserMeasurementPromise;
  deleteManyUserMeasurements: (
    where?: UserMeasurementWhereInput
  ) => BatchPayloadPromise;
  createWorkout: (data: WorkoutCreateInput) => WorkoutPromise;
  updateWorkout: (args: {
    data: WorkoutUpdateInput;
    where: WorkoutWhereUniqueInput;
  }) => WorkoutPromise;
  updateManyWorkouts: (args: {
    data: WorkoutUpdateManyMutationInput;
    where?: WorkoutWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkout: (args: {
    where: WorkoutWhereUniqueInput;
    create: WorkoutCreateInput;
    update: WorkoutUpdateInput;
  }) => WorkoutPromise;
  deleteWorkout: (where: WorkoutWhereUniqueInput) => WorkoutPromise;
  deleteManyWorkouts: (where?: WorkoutWhereInput) => BatchPayloadPromise;
  createWorkoutExercise: (
    data: WorkoutExerciseCreateInput
  ) => WorkoutExercisePromise;
  updateWorkoutExercise: (args: {
    data: WorkoutExerciseUpdateInput;
    where: WorkoutExerciseWhereUniqueInput;
  }) => WorkoutExercisePromise;
  upsertWorkoutExercise: (args: {
    where: WorkoutExerciseWhereUniqueInput;
    create: WorkoutExerciseCreateInput;
    update: WorkoutExerciseUpdateInput;
  }) => WorkoutExercisePromise;
  deleteWorkoutExercise: (
    where: WorkoutExerciseWhereUniqueInput
  ) => WorkoutExercisePromise;
  deleteManyWorkoutExercises: (
    where?: WorkoutExerciseWhereInput
  ) => BatchPayloadPromise;
  createWorkoutParameter: (
    data: WorkoutParameterCreateInput
  ) => WorkoutParameterPromise;
  updateWorkoutParameter: (args: {
    data: WorkoutParameterUpdateInput;
    where: WorkoutParameterWhereUniqueInput;
  }) => WorkoutParameterPromise;
  updateManyWorkoutParameters: (args: {
    data: WorkoutParameterUpdateManyMutationInput;
    where?: WorkoutParameterWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkoutParameter: (args: {
    where: WorkoutParameterWhereUniqueInput;
    create: WorkoutParameterCreateInput;
    update: WorkoutParameterUpdateInput;
  }) => WorkoutParameterPromise;
  deleteWorkoutParameter: (
    where: WorkoutParameterWhereUniqueInput
  ) => WorkoutParameterPromise;
  deleteManyWorkoutParameters: (
    where?: WorkoutParameterWhereInput
  ) => BatchPayloadPromise;
  createWorkoutPlan: (data: WorkoutPlanCreateInput) => WorkoutPlanPromise;
  updateWorkoutPlan: (args: {
    data: WorkoutPlanUpdateInput;
    where: WorkoutPlanWhereUniqueInput;
  }) => WorkoutPlanPromise;
  updateManyWorkoutPlans: (args: {
    data: WorkoutPlanUpdateManyMutationInput;
    where?: WorkoutPlanWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkoutPlan: (args: {
    where: WorkoutPlanWhereUniqueInput;
    create: WorkoutPlanCreateInput;
    update: WorkoutPlanUpdateInput;
  }) => WorkoutPlanPromise;
  deleteWorkoutPlan: (where: WorkoutPlanWhereUniqueInput) => WorkoutPlanPromise;
  deleteManyWorkoutPlans: (
    where?: WorkoutPlanWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  dailyExercise: (
    where?: DailyExerciseSubscriptionWhereInput
  ) => DailyExerciseSubscriptionPayloadSubscription;
  exercise: (
    where?: ExerciseSubscriptionWhereInput
  ) => ExerciseSubscriptionPayloadSubscription;
  exerciseParameter: (
    where?: ExerciseParameterSubscriptionWhereInput
  ) => ExerciseParameterSubscriptionPayloadSubscription;
  exerciseRoutine: (
    where?: ExerciseRoutineSubscriptionWhereInput
  ) => ExerciseRoutineSubscriptionPayloadSubscription;
  exerciseType: (
    where?: ExerciseTypeSubscriptionWhereInput
  ) => ExerciseTypeSubscriptionPayloadSubscription;
  measurement: (
    where?: MeasurementSubscriptionWhereInput
  ) => MeasurementSubscriptionPayloadSubscription;
  routine: (
    where?: RoutineSubscriptionWhereInput
  ) => RoutineSubscriptionPayloadSubscription;
  routineWorkoutPlan: (
    where?: RoutineWorkoutPlanSubscriptionWhereInput
  ) => RoutineWorkoutPlanSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userMeasurement: (
    where?: UserMeasurementSubscriptionWhereInput
  ) => UserMeasurementSubscriptionPayloadSubscription;
  workout: (
    where?: WorkoutSubscriptionWhereInput
  ) => WorkoutSubscriptionPayloadSubscription;
  workoutExercise: (
    where?: WorkoutExerciseSubscriptionWhereInput
  ) => WorkoutExerciseSubscriptionPayloadSubscription;
  workoutParameter: (
    where?: WorkoutParameterSubscriptionWhereInput
  ) => WorkoutParameterSubscriptionPayloadSubscription;
  workoutPlan: (
    where?: WorkoutPlanSubscriptionWhereInput
  ) => WorkoutPlanSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ExerciseParameterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type WorkoutParameterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC";

export type DailyExerciseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC";

export type ExerciseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type ExerciseRoutineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type ExerciseTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MeasurementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "description_ASC"
  | "description_DESC";

export type RoutineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type RoutineWorkoutPlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type UserMeasurementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "value_ASC"
  | "value_DESC";

export type WorkoutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC";

export type WorkoutExerciseOrderByInput = "id_ASC" | "id_DESC";

export type WorkoutPlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DailyExerciseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExerciseParameterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExerciseParameterWhereInput[] | ExerciseParameterWhereInput>;
  OR?: Maybe<ExerciseParameterWhereInput[] | ExerciseParameterWhereInput>;
  NOT?: Maybe<ExerciseParameterWhereInput[] | ExerciseParameterWhereInput>;
}

export interface WorkoutParameterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parameter?: Maybe<ExerciseParameterWhereInput>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  AND?: Maybe<WorkoutParameterWhereInput[] | WorkoutParameterWhereInput>;
  OR?: Maybe<WorkoutParameterWhereInput[] | WorkoutParameterWhereInput>;
  NOT?: Maybe<WorkoutParameterWhereInput[] | WorkoutParameterWhereInput>;
}

export interface DailyExerciseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  exercise?: Maybe<ExerciseWhereInput>;
  parameters_every?: Maybe<WorkoutParameterWhereInput>;
  parameters_some?: Maybe<WorkoutParameterWhereInput>;
  parameters_none?: Maybe<WorkoutParameterWhereInput>;
  AND?: Maybe<DailyExerciseWhereInput[] | DailyExerciseWhereInput>;
  OR?: Maybe<DailyExerciseWhereInput[] | DailyExerciseWhereInput>;
  NOT?: Maybe<DailyExerciseWhereInput[] | DailyExerciseWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ExerciseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<ExerciseTypeWhereInput>;
  AND?: Maybe<ExerciseWhereInput[] | ExerciseWhereInput>;
  OR?: Maybe<ExerciseWhereInput[] | ExerciseWhereInput>;
  NOT?: Maybe<ExerciseWhereInput[] | ExerciseWhereInput>;
}

export interface ExerciseTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  parameters_every?: Maybe<ExerciseParameterWhereInput>;
  parameters_some?: Maybe<ExerciseParameterWhereInput>;
  parameters_none?: Maybe<ExerciseParameterWhereInput>;
  AND?: Maybe<ExerciseTypeWhereInput[] | ExerciseTypeWhereInput>;
  OR?: Maybe<ExerciseTypeWhereInput[] | ExerciseTypeWhereInput>;
  NOT?: Maybe<ExerciseTypeWhereInput[] | ExerciseTypeWhereInput>;
}

export type ExerciseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExerciseParameterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExerciseRoutineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExerciseRoutineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  exercise?: Maybe<ExerciseWhereInput>;
  routine?: Maybe<RoutineWhereInput>;
  AND?: Maybe<ExerciseRoutineWhereInput[] | ExerciseRoutineWhereInput>;
  OR?: Maybe<ExerciseRoutineWhereInput[] | ExerciseRoutineWhereInput>;
  NOT?: Maybe<ExerciseRoutineWhereInput[] | ExerciseRoutineWhereInput>;
}

export interface RoutineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RoutineWhereInput[] | RoutineWhereInput>;
  OR?: Maybe<RoutineWhereInput[] | RoutineWhereInput>;
  NOT?: Maybe<RoutineWhereInput[] | RoutineWhereInput>;
}

export type ExerciseTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MeasurementWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface MeasurementWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  unit?: Maybe<String>;
  unit_not?: Maybe<String>;
  unit_in?: Maybe<String[] | String>;
  unit_not_in?: Maybe<String[] | String>;
  unit_lt?: Maybe<String>;
  unit_lte?: Maybe<String>;
  unit_gt?: Maybe<String>;
  unit_gte?: Maybe<String>;
  unit_contains?: Maybe<String>;
  unit_not_contains?: Maybe<String>;
  unit_starts_with?: Maybe<String>;
  unit_not_starts_with?: Maybe<String>;
  unit_ends_with?: Maybe<String>;
  unit_not_ends_with?: Maybe<String>;
  addedBy?: Maybe<UserWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
  OR?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
  NOT?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
}

export type RoutineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RoutineWorkoutPlanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoutineWorkoutPlanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  routine?: Maybe<RoutineWhereInput>;
  plan?: Maybe<WorkoutPlanWhereInput>;
  AND?: Maybe<RoutineWorkoutPlanWhereInput[] | RoutineWorkoutPlanWhereInput>;
  OR?: Maybe<RoutineWorkoutPlanWhereInput[] | RoutineWorkoutPlanWhereInput>;
  NOT?: Maybe<RoutineWorkoutPlanWhereInput[] | RoutineWorkoutPlanWhereInput>;
}

export interface WorkoutPlanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<WorkoutPlanWhereInput[] | WorkoutPlanWhereInput>;
  OR?: Maybe<WorkoutPlanWhereInput[] | WorkoutPlanWhereInput>;
  NOT?: Maybe<WorkoutPlanWhereInput[] | WorkoutPlanWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type UserMeasurementWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserMeasurementWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  measurement?: Maybe<MeasurementWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  AND?: Maybe<UserMeasurementWhereInput[] | UserMeasurementWhereInput>;
  OR?: Maybe<UserMeasurementWhereInput[] | UserMeasurementWhereInput>;
  NOT?: Maybe<UserMeasurementWhereInput[] | UserMeasurementWhereInput>;
}

export type WorkoutWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WorkoutWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  plan?: Maybe<WorkoutPlanWhereInput>;
  routine?: Maybe<RoutineWhereInput>;
  AND?: Maybe<WorkoutWhereInput[] | WorkoutWhereInput>;
  OR?: Maybe<WorkoutWhereInput[] | WorkoutWhereInput>;
  NOT?: Maybe<WorkoutWhereInput[] | WorkoutWhereInput>;
}

export type WorkoutExerciseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WorkoutExerciseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workout?: Maybe<WorkoutWhereInput>;
  exercise?: Maybe<ExerciseWhereInput>;
  parameters_every?: Maybe<WorkoutParameterWhereInput>;
  parameters_some?: Maybe<WorkoutParameterWhereInput>;
  parameters_none?: Maybe<WorkoutParameterWhereInput>;
  AND?: Maybe<WorkoutExerciseWhereInput[] | WorkoutExerciseWhereInput>;
  OR?: Maybe<WorkoutExerciseWhereInput[] | WorkoutExerciseWhereInput>;
  NOT?: Maybe<WorkoutExerciseWhereInput[] | WorkoutExerciseWhereInput>;
}

export type WorkoutParameterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WorkoutPlanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DailyExerciseCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  date: DateTimeInput;
  exercise: ExerciseCreateOneInput;
  parameters?: Maybe<WorkoutParameterCreateManyInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
}

export interface ExerciseCreateOneInput {
  create?: Maybe<ExerciseCreateInput>;
  connect?: Maybe<ExerciseWhereUniqueInput>;
}

export interface ExerciseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type: ExerciseTypeCreateOneInput;
}

export interface ExerciseTypeCreateOneInput {
  create?: Maybe<ExerciseTypeCreateInput>;
  connect?: Maybe<ExerciseTypeWhereUniqueInput>;
}

export interface ExerciseTypeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  parameters?: Maybe<ExerciseParameterCreateManyInput>;
}

export interface ExerciseParameterCreateManyInput {
  create?: Maybe<ExerciseParameterCreateInput[] | ExerciseParameterCreateInput>;
  connect?: Maybe<
    ExerciseParameterWhereUniqueInput[] | ExerciseParameterWhereUniqueInput
  >;
}

export interface ExerciseParameterCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
}

export interface WorkoutParameterCreateManyInput {
  create?: Maybe<WorkoutParameterCreateInput[] | WorkoutParameterCreateInput>;
  connect?: Maybe<
    WorkoutParameterWhereUniqueInput[] | WorkoutParameterWhereUniqueInput
  >;
}

export interface WorkoutParameterCreateInput {
  id?: Maybe<ID_Input>;
  parameter: ExerciseParameterCreateOneInput;
  value?: Maybe<Float>;
}

export interface ExerciseParameterCreateOneInput {
  create?: Maybe<ExerciseParameterCreateInput>;
  connect?: Maybe<ExerciseParameterWhereUniqueInput>;
}

export interface DailyExerciseUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  exercise?: Maybe<ExerciseUpdateOneRequiredInput>;
  parameters?: Maybe<WorkoutParameterUpdateManyInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ExerciseUpdateOneRequiredInput {
  create?: Maybe<ExerciseCreateInput>;
  update?: Maybe<ExerciseUpdateDataInput>;
  upsert?: Maybe<ExerciseUpsertNestedInput>;
  connect?: Maybe<ExerciseWhereUniqueInput>;
}

export interface ExerciseUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<ExerciseTypeUpdateOneRequiredInput>;
}

export interface ExerciseTypeUpdateOneRequiredInput {
  create?: Maybe<ExerciseTypeCreateInput>;
  update?: Maybe<ExerciseTypeUpdateDataInput>;
  upsert?: Maybe<ExerciseTypeUpsertNestedInput>;
  connect?: Maybe<ExerciseTypeWhereUniqueInput>;
}

export interface ExerciseTypeUpdateDataInput {
  name?: Maybe<String>;
  parameters?: Maybe<ExerciseParameterUpdateManyInput>;
}

export interface ExerciseParameterUpdateManyInput {
  create?: Maybe<ExerciseParameterCreateInput[] | ExerciseParameterCreateInput>;
  update?: Maybe<
    | ExerciseParameterUpdateWithWhereUniqueNestedInput[]
    | ExerciseParameterUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ExerciseParameterUpsertWithWhereUniqueNestedInput[]
    | ExerciseParameterUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ExerciseParameterWhereUniqueInput[] | ExerciseParameterWhereUniqueInput
  >;
  connect?: Maybe<
    ExerciseParameterWhereUniqueInput[] | ExerciseParameterWhereUniqueInput
  >;
  set?: Maybe<
    ExerciseParameterWhereUniqueInput[] | ExerciseParameterWhereUniqueInput
  >;
  disconnect?: Maybe<
    ExerciseParameterWhereUniqueInput[] | ExerciseParameterWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ExerciseParameterScalarWhereInput[] | ExerciseParameterScalarWhereInput
  >;
  updateMany?: Maybe<
    | ExerciseParameterUpdateManyWithWhereNestedInput[]
    | ExerciseParameterUpdateManyWithWhereNestedInput
  >;
}

export interface ExerciseParameterUpdateWithWhereUniqueNestedInput {
  where: ExerciseParameterWhereUniqueInput;
  data: ExerciseParameterUpdateDataInput;
}

export interface ExerciseParameterUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExerciseParameterUpsertWithWhereUniqueNestedInput {
  where: ExerciseParameterWhereUniqueInput;
  update: ExerciseParameterUpdateDataInput;
  create: ExerciseParameterCreateInput;
}

export interface ExerciseParameterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ExerciseParameterScalarWhereInput[] | ExerciseParameterScalarWhereInput
  >;
  OR?: Maybe<
    ExerciseParameterScalarWhereInput[] | ExerciseParameterScalarWhereInput
  >;
  NOT?: Maybe<
    ExerciseParameterScalarWhereInput[] | ExerciseParameterScalarWhereInput
  >;
}

export interface ExerciseParameterUpdateManyWithWhereNestedInput {
  where: ExerciseParameterScalarWhereInput;
  data: ExerciseParameterUpdateManyDataInput;
}

export interface ExerciseParameterUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExerciseTypeUpsertNestedInput {
  update: ExerciseTypeUpdateDataInput;
  create: ExerciseTypeCreateInput;
}

export interface ExerciseUpsertNestedInput {
  update: ExerciseUpdateDataInput;
  create: ExerciseCreateInput;
}

export interface WorkoutParameterUpdateManyInput {
  create?: Maybe<WorkoutParameterCreateInput[] | WorkoutParameterCreateInput>;
  update?: Maybe<
    | WorkoutParameterUpdateWithWhereUniqueNestedInput[]
    | WorkoutParameterUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | WorkoutParameterUpsertWithWhereUniqueNestedInput[]
    | WorkoutParameterUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    WorkoutParameterWhereUniqueInput[] | WorkoutParameterWhereUniqueInput
  >;
  connect?: Maybe<
    WorkoutParameterWhereUniqueInput[] | WorkoutParameterWhereUniqueInput
  >;
  set?: Maybe<
    WorkoutParameterWhereUniqueInput[] | WorkoutParameterWhereUniqueInput
  >;
  disconnect?: Maybe<
    WorkoutParameterWhereUniqueInput[] | WorkoutParameterWhereUniqueInput
  >;
  deleteMany?: Maybe<
    WorkoutParameterScalarWhereInput[] | WorkoutParameterScalarWhereInput
  >;
  updateMany?: Maybe<
    | WorkoutParameterUpdateManyWithWhereNestedInput[]
    | WorkoutParameterUpdateManyWithWhereNestedInput
  >;
}

export interface WorkoutParameterUpdateWithWhereUniqueNestedInput {
  where: WorkoutParameterWhereUniqueInput;
  data: WorkoutParameterUpdateDataInput;
}

export interface WorkoutParameterUpdateDataInput {
  parameter?: Maybe<ExerciseParameterUpdateOneRequiredInput>;
  value?: Maybe<Float>;
}

export interface ExerciseParameterUpdateOneRequiredInput {
  create?: Maybe<ExerciseParameterCreateInput>;
  update?: Maybe<ExerciseParameterUpdateDataInput>;
  upsert?: Maybe<ExerciseParameterUpsertNestedInput>;
  connect?: Maybe<ExerciseParameterWhereUniqueInput>;
}

export interface ExerciseParameterUpsertNestedInput {
  update: ExerciseParameterUpdateDataInput;
  create: ExerciseParameterCreateInput;
}

export interface WorkoutParameterUpsertWithWhereUniqueNestedInput {
  where: WorkoutParameterWhereUniqueInput;
  update: WorkoutParameterUpdateDataInput;
  create: WorkoutParameterCreateInput;
}

export interface WorkoutParameterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  AND?: Maybe<
    WorkoutParameterScalarWhereInput[] | WorkoutParameterScalarWhereInput
  >;
  OR?: Maybe<
    WorkoutParameterScalarWhereInput[] | WorkoutParameterScalarWhereInput
  >;
  NOT?: Maybe<
    WorkoutParameterScalarWhereInput[] | WorkoutParameterScalarWhereInput
  >;
}

export interface WorkoutParameterUpdateManyWithWhereNestedInput {
  where: WorkoutParameterScalarWhereInput;
  data: WorkoutParameterUpdateManyDataInput;
}

export interface WorkoutParameterUpdateManyDataInput {
  value?: Maybe<Float>;
}

export interface DailyExerciseUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
}

export interface ExerciseUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<ExerciseTypeUpdateOneRequiredInput>;
}

export interface ExerciseUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExerciseParameterUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExerciseParameterUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ExerciseRoutineCreateInput {
  id?: Maybe<ID_Input>;
  order: Int;
  exercise: ExerciseCreateOneInput;
  routine: RoutineCreateOneInput;
}

export interface RoutineCreateOneInput {
  create?: Maybe<RoutineCreateInput>;
  connect?: Maybe<RoutineWhereUniqueInput>;
}

export interface RoutineCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ExerciseRoutineUpdateInput {
  order?: Maybe<Int>;
  exercise?: Maybe<ExerciseUpdateOneRequiredInput>;
  routine?: Maybe<RoutineUpdateOneRequiredInput>;
}

export interface RoutineUpdateOneRequiredInput {
  create?: Maybe<RoutineCreateInput>;
  update?: Maybe<RoutineUpdateDataInput>;
  upsert?: Maybe<RoutineUpsertNestedInput>;
  connect?: Maybe<RoutineWhereUniqueInput>;
}

export interface RoutineUpdateDataInput {
  name?: Maybe<String>;
}

export interface RoutineUpsertNestedInput {
  update: RoutineUpdateDataInput;
  create: RoutineCreateInput;
}

export interface ExerciseRoutineUpdateManyMutationInput {
  order?: Maybe<Int>;
}

export interface ExerciseTypeUpdateInput {
  name?: Maybe<String>;
  parameters?: Maybe<ExerciseParameterUpdateManyInput>;
}

export interface ExerciseTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface MeasurementCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  unit: String;
  addedBy: UserCreateOneInput;
  description?: Maybe<String>;
}

export interface MeasurementUpdateInput {
  name?: Maybe<String>;
  unit?: Maybe<String>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
  description?: Maybe<String>;
}

export interface MeasurementUpdateManyMutationInput {
  name?: Maybe<String>;
  unit?: Maybe<String>;
  description?: Maybe<String>;
}

export interface RoutineUpdateInput {
  name?: Maybe<String>;
}

export interface RoutineUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RoutineWorkoutPlanCreateInput {
  id?: Maybe<ID_Input>;
  order: Int;
  routine: RoutineCreateOneInput;
  plan: WorkoutPlanCreateOneInput;
}

export interface WorkoutPlanCreateOneInput {
  create?: Maybe<WorkoutPlanCreateInput>;
  connect?: Maybe<WorkoutPlanWhereUniqueInput>;
}

export interface WorkoutPlanCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
}

export interface RoutineWorkoutPlanUpdateInput {
  order?: Maybe<Int>;
  routine?: Maybe<RoutineUpdateOneRequiredInput>;
  plan?: Maybe<WorkoutPlanUpdateOneRequiredInput>;
}

export interface WorkoutPlanUpdateOneRequiredInput {
  create?: Maybe<WorkoutPlanCreateInput>;
  update?: Maybe<WorkoutPlanUpdateDataInput>;
  upsert?: Maybe<WorkoutPlanUpsertNestedInput>;
  connect?: Maybe<WorkoutPlanWhereUniqueInput>;
}

export interface WorkoutPlanUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface WorkoutPlanUpsertNestedInput {
  update: WorkoutPlanUpdateDataInput;
  create: WorkoutPlanCreateInput;
}

export interface RoutineWorkoutPlanUpdateManyMutationInput {
  order?: Maybe<Int>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserMeasurementCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  measurement: MeasurementCreateOneInput;
  date: DateTimeInput;
  value: Float;
}

export interface MeasurementCreateOneInput {
  create?: Maybe<MeasurementCreateInput>;
  connect?: Maybe<MeasurementWhereUniqueInput>;
}

export interface UserMeasurementUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  measurement?: Maybe<MeasurementUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  value?: Maybe<Float>;
}

export interface MeasurementUpdateOneRequiredInput {
  create?: Maybe<MeasurementCreateInput>;
  update?: Maybe<MeasurementUpdateDataInput>;
  upsert?: Maybe<MeasurementUpsertNestedInput>;
  connect?: Maybe<MeasurementWhereUniqueInput>;
}

export interface MeasurementUpdateDataInput {
  name?: Maybe<String>;
  unit?: Maybe<String>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
  description?: Maybe<String>;
}

export interface MeasurementUpsertNestedInput {
  update: MeasurementUpdateDataInput;
  create: MeasurementCreateInput;
}

export interface UserMeasurementUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  value?: Maybe<Float>;
}

export interface WorkoutCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  date: DateTimeInput;
  plan: WorkoutPlanCreateOneInput;
  routine: RoutineCreateOneInput;
}

export interface WorkoutUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  plan?: Maybe<WorkoutPlanUpdateOneRequiredInput>;
  routine?: Maybe<RoutineUpdateOneRequiredInput>;
}

export interface WorkoutUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
}

export interface WorkoutExerciseCreateInput {
  id?: Maybe<ID_Input>;
  workout: WorkoutCreateOneInput;
  exercise: ExerciseCreateOneInput;
  parameters?: Maybe<WorkoutParameterCreateManyInput>;
}

export interface WorkoutCreateOneInput {
  create?: Maybe<WorkoutCreateInput>;
  connect?: Maybe<WorkoutWhereUniqueInput>;
}

export interface WorkoutExerciseUpdateInput {
  workout?: Maybe<WorkoutUpdateOneRequiredInput>;
  exercise?: Maybe<ExerciseUpdateOneRequiredInput>;
  parameters?: Maybe<WorkoutParameterUpdateManyInput>;
}

export interface WorkoutUpdateOneRequiredInput {
  create?: Maybe<WorkoutCreateInput>;
  update?: Maybe<WorkoutUpdateDataInput>;
  upsert?: Maybe<WorkoutUpsertNestedInput>;
  connect?: Maybe<WorkoutWhereUniqueInput>;
}

export interface WorkoutUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
  plan?: Maybe<WorkoutPlanUpdateOneRequiredInput>;
  routine?: Maybe<RoutineUpdateOneRequiredInput>;
}

export interface WorkoutUpsertNestedInput {
  update: WorkoutUpdateDataInput;
  create: WorkoutCreateInput;
}

export interface WorkoutParameterUpdateInput {
  parameter?: Maybe<ExerciseParameterUpdateOneRequiredInput>;
  value?: Maybe<Float>;
}

export interface WorkoutParameterUpdateManyMutationInput {
  value?: Maybe<Float>;
}

export interface WorkoutPlanUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface WorkoutPlanUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface DailyExerciseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DailyExerciseWhereInput>;
  AND?: Maybe<
    DailyExerciseSubscriptionWhereInput[] | DailyExerciseSubscriptionWhereInput
  >;
  OR?: Maybe<
    DailyExerciseSubscriptionWhereInput[] | DailyExerciseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DailyExerciseSubscriptionWhereInput[] | DailyExerciseSubscriptionWhereInput
  >;
}

export interface ExerciseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExerciseWhereInput>;
  AND?: Maybe<
    ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput
  >;
  OR?: Maybe<ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput>;
  NOT?: Maybe<
    ExerciseSubscriptionWhereInput[] | ExerciseSubscriptionWhereInput
  >;
}

export interface ExerciseParameterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExerciseParameterWhereInput>;
  AND?: Maybe<
    | ExerciseParameterSubscriptionWhereInput[]
    | ExerciseParameterSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExerciseParameterSubscriptionWhereInput[]
    | ExerciseParameterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExerciseParameterSubscriptionWhereInput[]
    | ExerciseParameterSubscriptionWhereInput
  >;
}

export interface ExerciseRoutineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExerciseRoutineWhereInput>;
  AND?: Maybe<
    | ExerciseRoutineSubscriptionWhereInput[]
    | ExerciseRoutineSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExerciseRoutineSubscriptionWhereInput[]
    | ExerciseRoutineSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExerciseRoutineSubscriptionWhereInput[]
    | ExerciseRoutineSubscriptionWhereInput
  >;
}

export interface ExerciseTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExerciseTypeWhereInput>;
  AND?: Maybe<
    ExerciseTypeSubscriptionWhereInput[] | ExerciseTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExerciseTypeSubscriptionWhereInput[] | ExerciseTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExerciseTypeSubscriptionWhereInput[] | ExerciseTypeSubscriptionWhereInput
  >;
}

export interface MeasurementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementWhereInput>;
  AND?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
  OR?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
}

export interface RoutineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoutineWhereInput>;
  AND?: Maybe<RoutineSubscriptionWhereInput[] | RoutineSubscriptionWhereInput>;
  OR?: Maybe<RoutineSubscriptionWhereInput[] | RoutineSubscriptionWhereInput>;
  NOT?: Maybe<RoutineSubscriptionWhereInput[] | RoutineSubscriptionWhereInput>;
}

export interface RoutineWorkoutPlanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoutineWorkoutPlanWhereInput>;
  AND?: Maybe<
    | RoutineWorkoutPlanSubscriptionWhereInput[]
    | RoutineWorkoutPlanSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RoutineWorkoutPlanSubscriptionWhereInput[]
    | RoutineWorkoutPlanSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RoutineWorkoutPlanSubscriptionWhereInput[]
    | RoutineWorkoutPlanSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserMeasurementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserMeasurementWhereInput>;
  AND?: Maybe<
    | UserMeasurementSubscriptionWhereInput[]
    | UserMeasurementSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserMeasurementSubscriptionWhereInput[]
    | UserMeasurementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserMeasurementSubscriptionWhereInput[]
    | UserMeasurementSubscriptionWhereInput
  >;
}

export interface WorkoutSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkoutWhereInput>;
  AND?: Maybe<WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput>;
  OR?: Maybe<WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput>;
  NOT?: Maybe<WorkoutSubscriptionWhereInput[] | WorkoutSubscriptionWhereInput>;
}

export interface WorkoutExerciseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkoutExerciseWhereInput>;
  AND?: Maybe<
    | WorkoutExerciseSubscriptionWhereInput[]
    | WorkoutExerciseSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WorkoutExerciseSubscriptionWhereInput[]
    | WorkoutExerciseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WorkoutExerciseSubscriptionWhereInput[]
    | WorkoutExerciseSubscriptionWhereInput
  >;
}

export interface WorkoutParameterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkoutParameterWhereInput>;
  AND?: Maybe<
    | WorkoutParameterSubscriptionWhereInput[]
    | WorkoutParameterSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WorkoutParameterSubscriptionWhereInput[]
    | WorkoutParameterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WorkoutParameterSubscriptionWhereInput[]
    | WorkoutParameterSubscriptionWhereInput
  >;
}

export interface WorkoutPlanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkoutPlanWhereInput>;
  AND?: Maybe<
    WorkoutPlanSubscriptionWhereInput[] | WorkoutPlanSubscriptionWhereInput
  >;
  OR?: Maybe<
    WorkoutPlanSubscriptionWhereInput[] | WorkoutPlanSubscriptionWhereInput
  >;
  NOT?: Maybe<
    WorkoutPlanSubscriptionWhereInput[] | WorkoutPlanSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface DailyExercise {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface DailyExercisePromise
  extends Promise<DailyExercise>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  exercise: <T = ExercisePromise>() => T;
  parameters: <T = FragmentableArray<WorkoutParameter>>(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DailyExerciseSubscription
  extends Promise<AsyncIterator<DailyExercise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  exercise: <T = ExerciseSubscription>() => T;
  parameters: <
    T = Promise<AsyncIterator<WorkoutParameterSubscription>>
  >(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DailyExerciseNullablePromise
  extends Promise<DailyExercise | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  exercise: <T = ExercisePromise>() => T;
  parameters: <T = FragmentableArray<WorkoutParameter>>(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface Exercise {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface ExercisePromise extends Promise<Exercise>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: <T = ExerciseTypePromise>() => T;
}

export interface ExerciseSubscription
  extends Promise<AsyncIterator<Exercise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: <T = ExerciseTypeSubscription>() => T;
}

export interface ExerciseNullablePromise
  extends Promise<Exercise | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: <T = ExerciseTypePromise>() => T;
}

export interface ExerciseType {
  id: ID_Output;
  name: String;
}

export interface ExerciseTypePromise
  extends Promise<ExerciseType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  parameters: <T = FragmentableArray<ExerciseParameter>>(args?: {
    where?: ExerciseParameterWhereInput;
    orderBy?: ExerciseParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExerciseTypeSubscription
  extends Promise<AsyncIterator<ExerciseType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  parameters: <
    T = Promise<AsyncIterator<ExerciseParameterSubscription>>
  >(args?: {
    where?: ExerciseParameterWhereInput;
    orderBy?: ExerciseParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExerciseTypeNullablePromise
  extends Promise<ExerciseType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  parameters: <T = FragmentableArray<ExerciseParameter>>(args?: {
    where?: ExerciseParameterWhereInput;
    orderBy?: ExerciseParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExerciseParameter {
  id: ID_Output;
  name: String;
  description: String;
}

export interface ExerciseParameterPromise
  extends Promise<ExerciseParameter>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ExerciseParameterSubscription
  extends Promise<AsyncIterator<ExerciseParameter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExerciseParameterNullablePromise
  extends Promise<ExerciseParameter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface WorkoutParameter {
  id: ID_Output;
  value?: Float;
}

export interface WorkoutParameterPromise
  extends Promise<WorkoutParameter>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parameter: <T = ExerciseParameterPromise>() => T;
  value: () => Promise<Float>;
}

export interface WorkoutParameterSubscription
  extends Promise<AsyncIterator<WorkoutParameter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parameter: <T = ExerciseParameterSubscription>() => T;
  value: () => Promise<AsyncIterator<Float>>;
}

export interface WorkoutParameterNullablePromise
  extends Promise<WorkoutParameter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parameter: <T = ExerciseParameterPromise>() => T;
  value: () => Promise<Float>;
}

export interface DailyExerciseConnection {
  pageInfo: PageInfo;
  edges: DailyExerciseEdge[];
}

export interface DailyExerciseConnectionPromise
  extends Promise<DailyExerciseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DailyExerciseEdge>>() => T;
  aggregate: <T = AggregateDailyExercisePromise>() => T;
}

export interface DailyExerciseConnectionSubscription
  extends Promise<AsyncIterator<DailyExerciseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DailyExerciseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDailyExerciseSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DailyExerciseEdge {
  node: DailyExercise;
  cursor: String;
}

export interface DailyExerciseEdgePromise
  extends Promise<DailyExerciseEdge>,
    Fragmentable {
  node: <T = DailyExercisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DailyExerciseEdgeSubscription
  extends Promise<AsyncIterator<DailyExerciseEdge>>,
    Fragmentable {
  node: <T = DailyExerciseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDailyExercise {
  count: Int;
}

export interface AggregateDailyExercisePromise
  extends Promise<AggregateDailyExercise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDailyExerciseSubscription
  extends Promise<AsyncIterator<AggregateDailyExercise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseConnection {
  pageInfo: PageInfo;
  edges: ExerciseEdge[];
}

export interface ExerciseConnectionPromise
  extends Promise<ExerciseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExerciseEdge>>() => T;
  aggregate: <T = AggregateExercisePromise>() => T;
}

export interface ExerciseConnectionSubscription
  extends Promise<AsyncIterator<ExerciseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExerciseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExerciseSubscription>() => T;
}

export interface ExerciseEdge {
  node: Exercise;
  cursor: String;
}

export interface ExerciseEdgePromise
  extends Promise<ExerciseEdge>,
    Fragmentable {
  node: <T = ExercisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExerciseEdgeSubscription
  extends Promise<AsyncIterator<ExerciseEdge>>,
    Fragmentable {
  node: <T = ExerciseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExercise {
  count: Int;
}

export interface AggregateExercisePromise
  extends Promise<AggregateExercise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExerciseSubscription
  extends Promise<AsyncIterator<AggregateExercise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseParameterConnection {
  pageInfo: PageInfo;
  edges: ExerciseParameterEdge[];
}

export interface ExerciseParameterConnectionPromise
  extends Promise<ExerciseParameterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExerciseParameterEdge>>() => T;
  aggregate: <T = AggregateExerciseParameterPromise>() => T;
}

export interface ExerciseParameterConnectionSubscription
  extends Promise<AsyncIterator<ExerciseParameterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExerciseParameterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExerciseParameterSubscription>() => T;
}

export interface ExerciseParameterEdge {
  node: ExerciseParameter;
  cursor: String;
}

export interface ExerciseParameterEdgePromise
  extends Promise<ExerciseParameterEdge>,
    Fragmentable {
  node: <T = ExerciseParameterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExerciseParameterEdgeSubscription
  extends Promise<AsyncIterator<ExerciseParameterEdge>>,
    Fragmentable {
  node: <T = ExerciseParameterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExerciseParameter {
  count: Int;
}

export interface AggregateExerciseParameterPromise
  extends Promise<AggregateExerciseParameter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExerciseParameterSubscription
  extends Promise<AsyncIterator<AggregateExerciseParameter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseRoutine {
  id: ID_Output;
  order: Int;
}

export interface ExerciseRoutinePromise
  extends Promise<ExerciseRoutine>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  exercise: <T = ExercisePromise>() => T;
  routine: <T = RoutinePromise>() => T;
}

export interface ExerciseRoutineSubscription
  extends Promise<AsyncIterator<ExerciseRoutine>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  exercise: <T = ExerciseSubscription>() => T;
  routine: <T = RoutineSubscription>() => T;
}

export interface ExerciseRoutineNullablePromise
  extends Promise<ExerciseRoutine | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  exercise: <T = ExercisePromise>() => T;
  routine: <T = RoutinePromise>() => T;
}

export interface Routine {
  id: ID_Output;
  name: String;
}

export interface RoutinePromise extends Promise<Routine>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RoutineSubscription
  extends Promise<AsyncIterator<Routine>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoutineNullablePromise
  extends Promise<Routine | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExerciseRoutineConnection {
  pageInfo: PageInfo;
  edges: ExerciseRoutineEdge[];
}

export interface ExerciseRoutineConnectionPromise
  extends Promise<ExerciseRoutineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExerciseRoutineEdge>>() => T;
  aggregate: <T = AggregateExerciseRoutinePromise>() => T;
}

export interface ExerciseRoutineConnectionSubscription
  extends Promise<AsyncIterator<ExerciseRoutineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExerciseRoutineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExerciseRoutineSubscription>() => T;
}

export interface ExerciseRoutineEdge {
  node: ExerciseRoutine;
  cursor: String;
}

export interface ExerciseRoutineEdgePromise
  extends Promise<ExerciseRoutineEdge>,
    Fragmentable {
  node: <T = ExerciseRoutinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExerciseRoutineEdgeSubscription
  extends Promise<AsyncIterator<ExerciseRoutineEdge>>,
    Fragmentable {
  node: <T = ExerciseRoutineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExerciseRoutine {
  count: Int;
}

export interface AggregateExerciseRoutinePromise
  extends Promise<AggregateExerciseRoutine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExerciseRoutineSubscription
  extends Promise<AsyncIterator<AggregateExerciseRoutine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseTypeConnection {
  pageInfo: PageInfo;
  edges: ExerciseTypeEdge[];
}

export interface ExerciseTypeConnectionPromise
  extends Promise<ExerciseTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExerciseTypeEdge>>() => T;
  aggregate: <T = AggregateExerciseTypePromise>() => T;
}

export interface ExerciseTypeConnectionSubscription
  extends Promise<AsyncIterator<ExerciseTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExerciseTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExerciseTypeSubscription>() => T;
}

export interface ExerciseTypeEdge {
  node: ExerciseType;
  cursor: String;
}

export interface ExerciseTypeEdgePromise
  extends Promise<ExerciseTypeEdge>,
    Fragmentable {
  node: <T = ExerciseTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExerciseTypeEdgeSubscription
  extends Promise<AsyncIterator<ExerciseTypeEdge>>,
    Fragmentable {
  node: <T = ExerciseTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExerciseType {
  count: Int;
}

export interface AggregateExerciseTypePromise
  extends Promise<AggregateExerciseType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExerciseTypeSubscription
  extends Promise<AsyncIterator<AggregateExerciseType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Measurement {
  id: ID_Output;
  name: String;
  unit: String;
  description?: String;
}

export interface MeasurementPromise extends Promise<Measurement>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  unit: () => Promise<String>;
  addedBy: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface MeasurementSubscription
  extends Promise<AsyncIterator<Measurement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  addedBy: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementNullablePromise
  extends Promise<Measurement | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  unit: () => Promise<String>;
  addedBy: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface MeasurementConnection {
  pageInfo: PageInfo;
  edges: MeasurementEdge[];
}

export interface MeasurementConnectionPromise
  extends Promise<MeasurementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementEdge>>() => T;
  aggregate: <T = AggregateMeasurementPromise>() => T;
}

export interface MeasurementConnectionSubscription
  extends Promise<AsyncIterator<MeasurementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementSubscription>() => T;
}

export interface MeasurementEdge {
  node: Measurement;
  cursor: String;
}

export interface MeasurementEdgePromise
  extends Promise<MeasurementEdge>,
    Fragmentable {
  node: <T = MeasurementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementEdgeSubscription
  extends Promise<AsyncIterator<MeasurementEdge>>,
    Fragmentable {
  node: <T = MeasurementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeasurement {
  count: Int;
}

export interface AggregateMeasurementPromise
  extends Promise<AggregateMeasurement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementSubscription
  extends Promise<AsyncIterator<AggregateMeasurement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoutineConnection {
  pageInfo: PageInfo;
  edges: RoutineEdge[];
}

export interface RoutineConnectionPromise
  extends Promise<RoutineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoutineEdge>>() => T;
  aggregate: <T = AggregateRoutinePromise>() => T;
}

export interface RoutineConnectionSubscription
  extends Promise<AsyncIterator<RoutineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoutineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoutineSubscription>() => T;
}

export interface RoutineEdge {
  node: Routine;
  cursor: String;
}

export interface RoutineEdgePromise extends Promise<RoutineEdge>, Fragmentable {
  node: <T = RoutinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoutineEdgeSubscription
  extends Promise<AsyncIterator<RoutineEdge>>,
    Fragmentable {
  node: <T = RoutineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoutine {
  count: Int;
}

export interface AggregateRoutinePromise
  extends Promise<AggregateRoutine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoutineSubscription
  extends Promise<AsyncIterator<AggregateRoutine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoutineWorkoutPlan {
  id: ID_Output;
  order: Int;
}

export interface RoutineWorkoutPlanPromise
  extends Promise<RoutineWorkoutPlan>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  routine: <T = RoutinePromise>() => T;
  plan: <T = WorkoutPlanPromise>() => T;
}

export interface RoutineWorkoutPlanSubscription
  extends Promise<AsyncIterator<RoutineWorkoutPlan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  routine: <T = RoutineSubscription>() => T;
  plan: <T = WorkoutPlanSubscription>() => T;
}

export interface RoutineWorkoutPlanNullablePromise
  extends Promise<RoutineWorkoutPlan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  routine: <T = RoutinePromise>() => T;
  plan: <T = WorkoutPlanPromise>() => T;
}

export interface WorkoutPlan {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface WorkoutPlanPromise extends Promise<WorkoutPlan>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface WorkoutPlanSubscription
  extends Promise<AsyncIterator<WorkoutPlan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface WorkoutPlanNullablePromise
  extends Promise<WorkoutPlan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface RoutineWorkoutPlanConnection {
  pageInfo: PageInfo;
  edges: RoutineWorkoutPlanEdge[];
}

export interface RoutineWorkoutPlanConnectionPromise
  extends Promise<RoutineWorkoutPlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoutineWorkoutPlanEdge>>() => T;
  aggregate: <T = AggregateRoutineWorkoutPlanPromise>() => T;
}

export interface RoutineWorkoutPlanConnectionSubscription
  extends Promise<AsyncIterator<RoutineWorkoutPlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<RoutineWorkoutPlanEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateRoutineWorkoutPlanSubscription>() => T;
}

export interface RoutineWorkoutPlanEdge {
  node: RoutineWorkoutPlan;
  cursor: String;
}

export interface RoutineWorkoutPlanEdgePromise
  extends Promise<RoutineWorkoutPlanEdge>,
    Fragmentable {
  node: <T = RoutineWorkoutPlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoutineWorkoutPlanEdgeSubscription
  extends Promise<AsyncIterator<RoutineWorkoutPlanEdge>>,
    Fragmentable {
  node: <T = RoutineWorkoutPlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoutineWorkoutPlan {
  count: Int;
}

export interface AggregateRoutineWorkoutPlanPromise
  extends Promise<AggregateRoutineWorkoutPlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoutineWorkoutPlanSubscription
  extends Promise<AsyncIterator<AggregateRoutineWorkoutPlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserMeasurement {
  id: ID_Output;
  date: DateTimeOutput;
  value: Float;
}

export interface UserMeasurementPromise
  extends Promise<UserMeasurement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  measurement: <T = MeasurementPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  value: () => Promise<Float>;
}

export interface UserMeasurementSubscription
  extends Promise<AsyncIterator<UserMeasurement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  measurement: <T = MeasurementSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<Float>>;
}

export interface UserMeasurementNullablePromise
  extends Promise<UserMeasurement | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  measurement: <T = MeasurementPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  value: () => Promise<Float>;
}

export interface UserMeasurementConnection {
  pageInfo: PageInfo;
  edges: UserMeasurementEdge[];
}

export interface UserMeasurementConnectionPromise
  extends Promise<UserMeasurementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserMeasurementEdge>>() => T;
  aggregate: <T = AggregateUserMeasurementPromise>() => T;
}

export interface UserMeasurementConnectionSubscription
  extends Promise<AsyncIterator<UserMeasurementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserMeasurementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserMeasurementSubscription>() => T;
}

export interface UserMeasurementEdge {
  node: UserMeasurement;
  cursor: String;
}

export interface UserMeasurementEdgePromise
  extends Promise<UserMeasurementEdge>,
    Fragmentable {
  node: <T = UserMeasurementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserMeasurementEdgeSubscription
  extends Promise<AsyncIterator<UserMeasurementEdge>>,
    Fragmentable {
  node: <T = UserMeasurementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserMeasurement {
  count: Int;
}

export interface AggregateUserMeasurementPromise
  extends Promise<AggregateUserMeasurement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserMeasurementSubscription
  extends Promise<AsyncIterator<AggregateUserMeasurement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Workout {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface WorkoutPromise extends Promise<Workout>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  plan: <T = WorkoutPlanPromise>() => T;
  routine: <T = RoutinePromise>() => T;
}

export interface WorkoutSubscription
  extends Promise<AsyncIterator<Workout>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  plan: <T = WorkoutPlanSubscription>() => T;
  routine: <T = RoutineSubscription>() => T;
}

export interface WorkoutNullablePromise
  extends Promise<Workout | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  plan: <T = WorkoutPlanPromise>() => T;
  routine: <T = RoutinePromise>() => T;
}

export interface WorkoutConnection {
  pageInfo: PageInfo;
  edges: WorkoutEdge[];
}

export interface WorkoutConnectionPromise
  extends Promise<WorkoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkoutEdge>>() => T;
  aggregate: <T = AggregateWorkoutPromise>() => T;
}

export interface WorkoutConnectionSubscription
  extends Promise<AsyncIterator<WorkoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkoutSubscription>() => T;
}

export interface WorkoutEdge {
  node: Workout;
  cursor: String;
}

export interface WorkoutEdgePromise extends Promise<WorkoutEdge>, Fragmentable {
  node: <T = WorkoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkoutEdgeSubscription
  extends Promise<AsyncIterator<WorkoutEdge>>,
    Fragmentable {
  node: <T = WorkoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkout {
  count: Int;
}

export interface AggregateWorkoutPromise
  extends Promise<AggregateWorkout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkoutSubscription
  extends Promise<AsyncIterator<AggregateWorkout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkoutExercise {
  id: ID_Output;
}

export interface WorkoutExercisePromise
  extends Promise<WorkoutExercise>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  workout: <T = WorkoutPromise>() => T;
  exercise: <T = ExercisePromise>() => T;
  parameters: <T = FragmentableArray<WorkoutParameter>>(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkoutExerciseSubscription
  extends Promise<AsyncIterator<WorkoutExercise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  workout: <T = WorkoutSubscription>() => T;
  exercise: <T = ExerciseSubscription>() => T;
  parameters: <
    T = Promise<AsyncIterator<WorkoutParameterSubscription>>
  >(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkoutExerciseNullablePromise
  extends Promise<WorkoutExercise | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  workout: <T = WorkoutPromise>() => T;
  exercise: <T = ExercisePromise>() => T;
  parameters: <T = FragmentableArray<WorkoutParameter>>(args?: {
    where?: WorkoutParameterWhereInput;
    orderBy?: WorkoutParameterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkoutExerciseConnection {
  pageInfo: PageInfo;
  edges: WorkoutExerciseEdge[];
}

export interface WorkoutExerciseConnectionPromise
  extends Promise<WorkoutExerciseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkoutExerciseEdge>>() => T;
  aggregate: <T = AggregateWorkoutExercisePromise>() => T;
}

export interface WorkoutExerciseConnectionSubscription
  extends Promise<AsyncIterator<WorkoutExerciseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkoutExerciseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkoutExerciseSubscription>() => T;
}

export interface WorkoutExerciseEdge {
  node: WorkoutExercise;
  cursor: String;
}

export interface WorkoutExerciseEdgePromise
  extends Promise<WorkoutExerciseEdge>,
    Fragmentable {
  node: <T = WorkoutExercisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkoutExerciseEdgeSubscription
  extends Promise<AsyncIterator<WorkoutExerciseEdge>>,
    Fragmentable {
  node: <T = WorkoutExerciseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkoutExercise {
  count: Int;
}

export interface AggregateWorkoutExercisePromise
  extends Promise<AggregateWorkoutExercise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkoutExerciseSubscription
  extends Promise<AsyncIterator<AggregateWorkoutExercise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkoutParameterConnection {
  pageInfo: PageInfo;
  edges: WorkoutParameterEdge[];
}

export interface WorkoutParameterConnectionPromise
  extends Promise<WorkoutParameterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkoutParameterEdge>>() => T;
  aggregate: <T = AggregateWorkoutParameterPromise>() => T;
}

export interface WorkoutParameterConnectionSubscription
  extends Promise<AsyncIterator<WorkoutParameterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkoutParameterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkoutParameterSubscription>() => T;
}

export interface WorkoutParameterEdge {
  node: WorkoutParameter;
  cursor: String;
}

export interface WorkoutParameterEdgePromise
  extends Promise<WorkoutParameterEdge>,
    Fragmentable {
  node: <T = WorkoutParameterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkoutParameterEdgeSubscription
  extends Promise<AsyncIterator<WorkoutParameterEdge>>,
    Fragmentable {
  node: <T = WorkoutParameterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkoutParameter {
  count: Int;
}

export interface AggregateWorkoutParameterPromise
  extends Promise<AggregateWorkoutParameter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkoutParameterSubscription
  extends Promise<AsyncIterator<AggregateWorkoutParameter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkoutPlanConnection {
  pageInfo: PageInfo;
  edges: WorkoutPlanEdge[];
}

export interface WorkoutPlanConnectionPromise
  extends Promise<WorkoutPlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkoutPlanEdge>>() => T;
  aggregate: <T = AggregateWorkoutPlanPromise>() => T;
}

export interface WorkoutPlanConnectionSubscription
  extends Promise<AsyncIterator<WorkoutPlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkoutPlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkoutPlanSubscription>() => T;
}

export interface WorkoutPlanEdge {
  node: WorkoutPlan;
  cursor: String;
}

export interface WorkoutPlanEdgePromise
  extends Promise<WorkoutPlanEdge>,
    Fragmentable {
  node: <T = WorkoutPlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkoutPlanEdgeSubscription
  extends Promise<AsyncIterator<WorkoutPlanEdge>>,
    Fragmentable {
  node: <T = WorkoutPlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkoutPlan {
  count: Int;
}

export interface AggregateWorkoutPlanPromise
  extends Promise<AggregateWorkoutPlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkoutPlanSubscription
  extends Promise<AsyncIterator<AggregateWorkoutPlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DailyExerciseSubscriptionPayload {
  mutation: MutationType;
  node: DailyExercise;
  updatedFields: String[];
  previousValues: DailyExercisePreviousValues;
}

export interface DailyExerciseSubscriptionPayloadPromise
  extends Promise<DailyExerciseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DailyExercisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DailyExercisePreviousValuesPromise>() => T;
}

export interface DailyExerciseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DailyExerciseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DailyExerciseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DailyExercisePreviousValuesSubscription>() => T;
}

export interface DailyExercisePreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface DailyExercisePreviousValuesPromise
  extends Promise<DailyExercisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
}

export interface DailyExercisePreviousValuesSubscription
  extends Promise<AsyncIterator<DailyExercisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExerciseSubscriptionPayload {
  mutation: MutationType;
  node: Exercise;
  updatedFields: String[];
  previousValues: ExercisePreviousValues;
}

export interface ExerciseSubscriptionPayloadPromise
  extends Promise<ExerciseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExercisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExercisePreviousValuesPromise>() => T;
}

export interface ExerciseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExerciseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExerciseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExercisePreviousValuesSubscription>() => T;
}

export interface ExercisePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface ExercisePreviousValuesPromise
  extends Promise<ExercisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ExercisePreviousValuesSubscription
  extends Promise<AsyncIterator<ExercisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExerciseParameterSubscriptionPayload {
  mutation: MutationType;
  node: ExerciseParameter;
  updatedFields: String[];
  previousValues: ExerciseParameterPreviousValues;
}

export interface ExerciseParameterSubscriptionPayloadPromise
  extends Promise<ExerciseParameterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExerciseParameterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExerciseParameterPreviousValuesPromise>() => T;
}

export interface ExerciseParameterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExerciseParameterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExerciseParameterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExerciseParameterPreviousValuesSubscription>() => T;
}

export interface ExerciseParameterPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
}

export interface ExerciseParameterPreviousValuesPromise
  extends Promise<ExerciseParameterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ExerciseParameterPreviousValuesSubscription
  extends Promise<AsyncIterator<ExerciseParameterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExerciseRoutineSubscriptionPayload {
  mutation: MutationType;
  node: ExerciseRoutine;
  updatedFields: String[];
  previousValues: ExerciseRoutinePreviousValues;
}

export interface ExerciseRoutineSubscriptionPayloadPromise
  extends Promise<ExerciseRoutineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExerciseRoutinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExerciseRoutinePreviousValuesPromise>() => T;
}

export interface ExerciseRoutineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExerciseRoutineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExerciseRoutineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExerciseRoutinePreviousValuesSubscription>() => T;
}

export interface ExerciseRoutinePreviousValues {
  id: ID_Output;
  order: Int;
}

export interface ExerciseRoutinePreviousValuesPromise
  extends Promise<ExerciseRoutinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface ExerciseRoutinePreviousValuesSubscription
  extends Promise<AsyncIterator<ExerciseRoutinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ExerciseTypeSubscriptionPayload {
  mutation: MutationType;
  node: ExerciseType;
  updatedFields: String[];
  previousValues: ExerciseTypePreviousValues;
}

export interface ExerciseTypeSubscriptionPayloadPromise
  extends Promise<ExerciseTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExerciseTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExerciseTypePreviousValuesPromise>() => T;
}

export interface ExerciseTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExerciseTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExerciseTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExerciseTypePreviousValuesSubscription>() => T;
}

export interface ExerciseTypePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ExerciseTypePreviousValuesPromise
  extends Promise<ExerciseTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExerciseTypePreviousValuesSubscription
  extends Promise<AsyncIterator<ExerciseTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementSubscriptionPayload {
  mutation: MutationType;
  node: Measurement;
  updatedFields: String[];
  previousValues: MeasurementPreviousValues;
}

export interface MeasurementSubscriptionPayloadPromise
  extends Promise<MeasurementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementPreviousValuesPromise>() => T;
}

export interface MeasurementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementPreviousValuesSubscription>() => T;
}

export interface MeasurementPreviousValues {
  id: ID_Output;
  name: String;
  unit: String;
  description?: String;
}

export interface MeasurementPreviousValuesPromise
  extends Promise<MeasurementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  unit: () => Promise<String>;
  description: () => Promise<String>;
}

export interface MeasurementPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface RoutineSubscriptionPayload {
  mutation: MutationType;
  node: Routine;
  updatedFields: String[];
  previousValues: RoutinePreviousValues;
}

export interface RoutineSubscriptionPayloadPromise
  extends Promise<RoutineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoutinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoutinePreviousValuesPromise>() => T;
}

export interface RoutineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoutineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoutineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoutinePreviousValuesSubscription>() => T;
}

export interface RoutinePreviousValues {
  id: ID_Output;
  name: String;
}

export interface RoutinePreviousValuesPromise
  extends Promise<RoutinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RoutinePreviousValuesSubscription
  extends Promise<AsyncIterator<RoutinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoutineWorkoutPlanSubscriptionPayload {
  mutation: MutationType;
  node: RoutineWorkoutPlan;
  updatedFields: String[];
  previousValues: RoutineWorkoutPlanPreviousValues;
}

export interface RoutineWorkoutPlanSubscriptionPayloadPromise
  extends Promise<RoutineWorkoutPlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoutineWorkoutPlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoutineWorkoutPlanPreviousValuesPromise>() => T;
}

export interface RoutineWorkoutPlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoutineWorkoutPlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoutineWorkoutPlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoutineWorkoutPlanPreviousValuesSubscription>() => T;
}

export interface RoutineWorkoutPlanPreviousValues {
  id: ID_Output;
  order: Int;
}

export interface RoutineWorkoutPlanPreviousValuesPromise
  extends Promise<RoutineWorkoutPlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface RoutineWorkoutPlanPreviousValuesSubscription
  extends Promise<AsyncIterator<RoutineWorkoutPlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface UserMeasurementSubscriptionPayload {
  mutation: MutationType;
  node: UserMeasurement;
  updatedFields: String[];
  previousValues: UserMeasurementPreviousValues;
}

export interface UserMeasurementSubscriptionPayloadPromise
  extends Promise<UserMeasurementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserMeasurementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserMeasurementPreviousValuesPromise>() => T;
}

export interface UserMeasurementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserMeasurementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserMeasurementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserMeasurementPreviousValuesSubscription>() => T;
}

export interface UserMeasurementPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  value: Float;
}

export interface UserMeasurementPreviousValuesPromise
  extends Promise<UserMeasurementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  value: () => Promise<Float>;
}

export interface UserMeasurementPreviousValuesSubscription
  extends Promise<AsyncIterator<UserMeasurementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<Float>>;
}

export interface WorkoutSubscriptionPayload {
  mutation: MutationType;
  node: Workout;
  updatedFields: String[];
  previousValues: WorkoutPreviousValues;
}

export interface WorkoutSubscriptionPayloadPromise
  extends Promise<WorkoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkoutPreviousValuesPromise>() => T;
}

export interface WorkoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkoutPreviousValuesSubscription>() => T;
}

export interface WorkoutPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface WorkoutPreviousValuesPromise
  extends Promise<WorkoutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
}

export interface WorkoutPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkoutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WorkoutExerciseSubscriptionPayload {
  mutation: MutationType;
  node: WorkoutExercise;
  updatedFields: String[];
  previousValues: WorkoutExercisePreviousValues;
}

export interface WorkoutExerciseSubscriptionPayloadPromise
  extends Promise<WorkoutExerciseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkoutExercisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkoutExercisePreviousValuesPromise>() => T;
}

export interface WorkoutExerciseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkoutExerciseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkoutExerciseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkoutExercisePreviousValuesSubscription>() => T;
}

export interface WorkoutExercisePreviousValues {
  id: ID_Output;
}

export interface WorkoutExercisePreviousValuesPromise
  extends Promise<WorkoutExercisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WorkoutExercisePreviousValuesSubscription
  extends Promise<AsyncIterator<WorkoutExercisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface WorkoutParameterSubscriptionPayload {
  mutation: MutationType;
  node: WorkoutParameter;
  updatedFields: String[];
  previousValues: WorkoutParameterPreviousValues;
}

export interface WorkoutParameterSubscriptionPayloadPromise
  extends Promise<WorkoutParameterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkoutParameterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkoutParameterPreviousValuesPromise>() => T;
}

export interface WorkoutParameterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkoutParameterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkoutParameterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkoutParameterPreviousValuesSubscription>() => T;
}

export interface WorkoutParameterPreviousValues {
  id: ID_Output;
  value?: Float;
}

export interface WorkoutParameterPreviousValuesPromise
  extends Promise<WorkoutParameterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<Float>;
}

export interface WorkoutParameterPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkoutParameterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Float>>;
}

export interface WorkoutPlanSubscriptionPayload {
  mutation: MutationType;
  node: WorkoutPlan;
  updatedFields: String[];
  previousValues: WorkoutPlanPreviousValues;
}

export interface WorkoutPlanSubscriptionPayloadPromise
  extends Promise<WorkoutPlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkoutPlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkoutPlanPreviousValuesPromise>() => T;
}

export interface WorkoutPlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkoutPlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkoutPlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkoutPlanPreviousValuesSubscription>() => T;
}

export interface WorkoutPlanPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface WorkoutPlanPreviousValuesPromise
  extends Promise<WorkoutPlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface WorkoutPlanPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkoutPlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserMeasurement",
    embedded: false
  },
  {
    name: "Measurement",
    embedded: false
  },
  {
    name: "ExerciseParameter",
    embedded: false
  },
  {
    name: "ExerciseType",
    embedded: false
  },
  {
    name: "Exercise",
    embedded: false
  },
  {
    name: "ExerciseRoutine",
    embedded: false
  },
  {
    name: "Routine",
    embedded: false
  },
  {
    name: "RoutineWorkoutPlan",
    embedded: false
  },
  {
    name: "WorkoutPlan",
    embedded: false
  },
  {
    name: "Workout",
    embedded: false
  },
  {
    name: "WorkoutExercise",
    embedded: false
  },
  {
    name: "WorkoutParameter",
    embedded: false
  },
  {
    name: "DailyExercise",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
