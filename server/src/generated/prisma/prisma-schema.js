module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDailyExercise {
  count: Int!
}

type AggregateExercise {
  count: Int!
}

type AggregateExerciseParameter {
  count: Int!
}

type AggregateExerciseRoutine {
  count: Int!
}

type AggregateExerciseType {
  count: Int!
}

type AggregateMeasurement {
  count: Int!
}

type AggregateRoutine {
  count: Int!
}

type AggregateRoutineWorkoutPlan {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserMeasurement {
  count: Int!
}

type AggregateWorkout {
  count: Int!
}

type AggregateWorkoutExercise {
  count: Int!
}

type AggregateWorkoutParameter {
  count: Int!
}

type AggregateWorkoutPlan {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type DailyExercise {
  id: ID!
  user: User!
  date: DateTime!
  exercise: Exercise!
  parameters(where: WorkoutParameterWhereInput, orderBy: WorkoutParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutParameter!]
}

type DailyExerciseConnection {
  pageInfo: PageInfo!
  edges: [DailyExerciseEdge]!
  aggregate: AggregateDailyExercise!
}

input DailyExerciseCreateInput {
  id: ID
  user: UserCreateOneInput!
  date: DateTime!
  exercise: ExerciseCreateOneInput!
  parameters: WorkoutParameterCreateManyInput
}

type DailyExerciseEdge {
  node: DailyExercise!
  cursor: String!
}

enum DailyExerciseOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
}

type DailyExercisePreviousValues {
  id: ID!
  date: DateTime!
}

type DailyExerciseSubscriptionPayload {
  mutation: MutationType!
  node: DailyExercise
  updatedFields: [String!]
  previousValues: DailyExercisePreviousValues
}

input DailyExerciseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DailyExerciseWhereInput
  AND: [DailyExerciseSubscriptionWhereInput!]
  OR: [DailyExerciseSubscriptionWhereInput!]
  NOT: [DailyExerciseSubscriptionWhereInput!]
}

input DailyExerciseUpdateInput {
  user: UserUpdateOneRequiredInput
  date: DateTime
  exercise: ExerciseUpdateOneRequiredInput
  parameters: WorkoutParameterUpdateManyInput
}

input DailyExerciseUpdateManyMutationInput {
  date: DateTime
}

input DailyExerciseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  exercise: ExerciseWhereInput
  parameters_every: WorkoutParameterWhereInput
  parameters_some: WorkoutParameterWhereInput
  parameters_none: WorkoutParameterWhereInput
  AND: [DailyExerciseWhereInput!]
  OR: [DailyExerciseWhereInput!]
  NOT: [DailyExerciseWhereInput!]
}

input DailyExerciseWhereUniqueInput {
  id: ID
}

scalar DateTime

type Exercise {
  id: ID!
  name: String!
  description: String
  type: ExerciseType!
}

type ExerciseConnection {
  pageInfo: PageInfo!
  edges: [ExerciseEdge]!
  aggregate: AggregateExercise!
}

input ExerciseCreateInput {
  id: ID
  name: String!
  description: String
  type: ExerciseTypeCreateOneInput!
}

input ExerciseCreateOneInput {
  create: ExerciseCreateInput
  connect: ExerciseWhereUniqueInput
}

type ExerciseEdge {
  node: Exercise!
  cursor: String!
}

enum ExerciseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type ExerciseParameter {
  id: ID!
  name: String!
  description: String!
}

type ExerciseParameterConnection {
  pageInfo: PageInfo!
  edges: [ExerciseParameterEdge]!
  aggregate: AggregateExerciseParameter!
}

input ExerciseParameterCreateInput {
  id: ID
  name: String!
  description: String!
}

input ExerciseParameterCreateManyInput {
  create: [ExerciseParameterCreateInput!]
  connect: [ExerciseParameterWhereUniqueInput!]
}

input ExerciseParameterCreateOneInput {
  create: ExerciseParameterCreateInput
  connect: ExerciseParameterWhereUniqueInput
}

type ExerciseParameterEdge {
  node: ExerciseParameter!
  cursor: String!
}

enum ExerciseParameterOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type ExerciseParameterPreviousValues {
  id: ID!
  name: String!
  description: String!
}

input ExerciseParameterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ExerciseParameterScalarWhereInput!]
  OR: [ExerciseParameterScalarWhereInput!]
  NOT: [ExerciseParameterScalarWhereInput!]
}

type ExerciseParameterSubscriptionPayload {
  mutation: MutationType!
  node: ExerciseParameter
  updatedFields: [String!]
  previousValues: ExerciseParameterPreviousValues
}

input ExerciseParameterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExerciseParameterWhereInput
  AND: [ExerciseParameterSubscriptionWhereInput!]
  OR: [ExerciseParameterSubscriptionWhereInput!]
  NOT: [ExerciseParameterSubscriptionWhereInput!]
}

input ExerciseParameterUpdateDataInput {
  name: String
  description: String
}

input ExerciseParameterUpdateInput {
  name: String
  description: String
}

input ExerciseParameterUpdateManyDataInput {
  name: String
  description: String
}

input ExerciseParameterUpdateManyInput {
  create: [ExerciseParameterCreateInput!]
  update: [ExerciseParameterUpdateWithWhereUniqueNestedInput!]
  upsert: [ExerciseParameterUpsertWithWhereUniqueNestedInput!]
  delete: [ExerciseParameterWhereUniqueInput!]
  connect: [ExerciseParameterWhereUniqueInput!]
  set: [ExerciseParameterWhereUniqueInput!]
  disconnect: [ExerciseParameterWhereUniqueInput!]
  deleteMany: [ExerciseParameterScalarWhereInput!]
  updateMany: [ExerciseParameterUpdateManyWithWhereNestedInput!]
}

input ExerciseParameterUpdateManyMutationInput {
  name: String
  description: String
}

input ExerciseParameterUpdateManyWithWhereNestedInput {
  where: ExerciseParameterScalarWhereInput!
  data: ExerciseParameterUpdateManyDataInput!
}

input ExerciseParameterUpdateOneRequiredInput {
  create: ExerciseParameterCreateInput
  update: ExerciseParameterUpdateDataInput
  upsert: ExerciseParameterUpsertNestedInput
  connect: ExerciseParameterWhereUniqueInput
}

input ExerciseParameterUpdateWithWhereUniqueNestedInput {
  where: ExerciseParameterWhereUniqueInput!
  data: ExerciseParameterUpdateDataInput!
}

input ExerciseParameterUpsertNestedInput {
  update: ExerciseParameterUpdateDataInput!
  create: ExerciseParameterCreateInput!
}

input ExerciseParameterUpsertWithWhereUniqueNestedInput {
  where: ExerciseParameterWhereUniqueInput!
  update: ExerciseParameterUpdateDataInput!
  create: ExerciseParameterCreateInput!
}

input ExerciseParameterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ExerciseParameterWhereInput!]
  OR: [ExerciseParameterWhereInput!]
  NOT: [ExerciseParameterWhereInput!]
}

input ExerciseParameterWhereUniqueInput {
  id: ID
}

type ExercisePreviousValues {
  id: ID!
  name: String!
  description: String
}

type ExerciseRoutine {
  id: ID!
  order: Int!
  exercise: Exercise!
  routine: Routine!
}

type ExerciseRoutineConnection {
  pageInfo: PageInfo!
  edges: [ExerciseRoutineEdge]!
  aggregate: AggregateExerciseRoutine!
}

input ExerciseRoutineCreateInput {
  id: ID
  order: Int!
  exercise: ExerciseCreateOneInput!
  routine: RoutineCreateOneInput!
}

type ExerciseRoutineEdge {
  node: ExerciseRoutine!
  cursor: String!
}

enum ExerciseRoutineOrderByInput {
  id_ASC
  id_DESC
  order_ASC
  order_DESC
}

type ExerciseRoutinePreviousValues {
  id: ID!
  order: Int!
}

type ExerciseRoutineSubscriptionPayload {
  mutation: MutationType!
  node: ExerciseRoutine
  updatedFields: [String!]
  previousValues: ExerciseRoutinePreviousValues
}

input ExerciseRoutineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExerciseRoutineWhereInput
  AND: [ExerciseRoutineSubscriptionWhereInput!]
  OR: [ExerciseRoutineSubscriptionWhereInput!]
  NOT: [ExerciseRoutineSubscriptionWhereInput!]
}

input ExerciseRoutineUpdateInput {
  order: Int
  exercise: ExerciseUpdateOneRequiredInput
  routine: RoutineUpdateOneRequiredInput
}

input ExerciseRoutineUpdateManyMutationInput {
  order: Int
}

input ExerciseRoutineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  exercise: ExerciseWhereInput
  routine: RoutineWhereInput
  AND: [ExerciseRoutineWhereInput!]
  OR: [ExerciseRoutineWhereInput!]
  NOT: [ExerciseRoutineWhereInput!]
}

input ExerciseRoutineWhereUniqueInput {
  id: ID
}

type ExerciseSubscriptionPayload {
  mutation: MutationType!
  node: Exercise
  updatedFields: [String!]
  previousValues: ExercisePreviousValues
}

input ExerciseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExerciseWhereInput
  AND: [ExerciseSubscriptionWhereInput!]
  OR: [ExerciseSubscriptionWhereInput!]
  NOT: [ExerciseSubscriptionWhereInput!]
}

type ExerciseType {
  id: ID!
  name: String!
  parameters(where: ExerciseParameterWhereInput, orderBy: ExerciseParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExerciseParameter!]
}

type ExerciseTypeConnection {
  pageInfo: PageInfo!
  edges: [ExerciseTypeEdge]!
  aggregate: AggregateExerciseType!
}

input ExerciseTypeCreateInput {
  id: ID
  name: String!
  parameters: ExerciseParameterCreateManyInput
}

input ExerciseTypeCreateOneInput {
  create: ExerciseTypeCreateInput
  connect: ExerciseTypeWhereUniqueInput
}

type ExerciseTypeEdge {
  node: ExerciseType!
  cursor: String!
}

enum ExerciseTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ExerciseTypePreviousValues {
  id: ID!
  name: String!
}

type ExerciseTypeSubscriptionPayload {
  mutation: MutationType!
  node: ExerciseType
  updatedFields: [String!]
  previousValues: ExerciseTypePreviousValues
}

input ExerciseTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExerciseTypeWhereInput
  AND: [ExerciseTypeSubscriptionWhereInput!]
  OR: [ExerciseTypeSubscriptionWhereInput!]
  NOT: [ExerciseTypeSubscriptionWhereInput!]
}

input ExerciseTypeUpdateDataInput {
  name: String
  parameters: ExerciseParameterUpdateManyInput
}

input ExerciseTypeUpdateInput {
  name: String
  parameters: ExerciseParameterUpdateManyInput
}

input ExerciseTypeUpdateManyMutationInput {
  name: String
}

input ExerciseTypeUpdateOneRequiredInput {
  create: ExerciseTypeCreateInput
  update: ExerciseTypeUpdateDataInput
  upsert: ExerciseTypeUpsertNestedInput
  connect: ExerciseTypeWhereUniqueInput
}

input ExerciseTypeUpsertNestedInput {
  update: ExerciseTypeUpdateDataInput!
  create: ExerciseTypeCreateInput!
}

input ExerciseTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parameters_every: ExerciseParameterWhereInput
  parameters_some: ExerciseParameterWhereInput
  parameters_none: ExerciseParameterWhereInput
  AND: [ExerciseTypeWhereInput!]
  OR: [ExerciseTypeWhereInput!]
  NOT: [ExerciseTypeWhereInput!]
}

input ExerciseTypeWhereUniqueInput {
  id: ID
}

input ExerciseUpdateDataInput {
  name: String
  description: String
  type: ExerciseTypeUpdateOneRequiredInput
}

input ExerciseUpdateInput {
  name: String
  description: String
  type: ExerciseTypeUpdateOneRequiredInput
}

input ExerciseUpdateManyMutationInput {
  name: String
  description: String
}

input ExerciseUpdateOneRequiredInput {
  create: ExerciseCreateInput
  update: ExerciseUpdateDataInput
  upsert: ExerciseUpsertNestedInput
  connect: ExerciseWhereUniqueInput
}

input ExerciseUpsertNestedInput {
  update: ExerciseUpdateDataInput!
  create: ExerciseCreateInput!
}

input ExerciseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: ExerciseTypeWhereInput
  AND: [ExerciseWhereInput!]
  OR: [ExerciseWhereInput!]
  NOT: [ExerciseWhereInput!]
}

input ExerciseWhereUniqueInput {
  id: ID
}

scalar Long

type Measurement {
  id: ID!
  name: String!
  unit: String!
  addedBy: User!
  description: String
}

type MeasurementConnection {
  pageInfo: PageInfo!
  edges: [MeasurementEdge]!
  aggregate: AggregateMeasurement!
}

input MeasurementCreateInput {
  id: ID
  name: String!
  unit: String!
  addedBy: UserCreateOneInput!
  description: String
}

input MeasurementCreateOneInput {
  create: MeasurementCreateInput
  connect: MeasurementWhereUniqueInput
}

type MeasurementEdge {
  node: Measurement!
  cursor: String!
}

enum MeasurementOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  unit_ASC
  unit_DESC
  description_ASC
  description_DESC
}

type MeasurementPreviousValues {
  id: ID!
  name: String!
  unit: String!
  description: String
}

type MeasurementSubscriptionPayload {
  mutation: MutationType!
  node: Measurement
  updatedFields: [String!]
  previousValues: MeasurementPreviousValues
}

input MeasurementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementWhereInput
  AND: [MeasurementSubscriptionWhereInput!]
  OR: [MeasurementSubscriptionWhereInput!]
  NOT: [MeasurementSubscriptionWhereInput!]
}

input MeasurementUpdateDataInput {
  name: String
  unit: String
  addedBy: UserUpdateOneRequiredInput
  description: String
}

input MeasurementUpdateInput {
  name: String
  unit: String
  addedBy: UserUpdateOneRequiredInput
  description: String
}

input MeasurementUpdateManyMutationInput {
  name: String
  unit: String
  description: String
}

input MeasurementUpdateOneRequiredInput {
  create: MeasurementCreateInput
  update: MeasurementUpdateDataInput
  upsert: MeasurementUpsertNestedInput
  connect: MeasurementWhereUniqueInput
}

input MeasurementUpsertNestedInput {
  update: MeasurementUpdateDataInput!
  create: MeasurementCreateInput!
}

input MeasurementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  addedBy: UserWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [MeasurementWhereInput!]
  OR: [MeasurementWhereInput!]
  NOT: [MeasurementWhereInput!]
}

input MeasurementWhereUniqueInput {
  id: ID
}

type Mutation {
  createDailyExercise(data: DailyExerciseCreateInput!): DailyExercise!
  updateDailyExercise(data: DailyExerciseUpdateInput!, where: DailyExerciseWhereUniqueInput!): DailyExercise
  updateManyDailyExercises(data: DailyExerciseUpdateManyMutationInput!, where: DailyExerciseWhereInput): BatchPayload!
  upsertDailyExercise(where: DailyExerciseWhereUniqueInput!, create: DailyExerciseCreateInput!, update: DailyExerciseUpdateInput!): DailyExercise!
  deleteDailyExercise(where: DailyExerciseWhereUniqueInput!): DailyExercise
  deleteManyDailyExercises(where: DailyExerciseWhereInput): BatchPayload!
  createExercise(data: ExerciseCreateInput!): Exercise!
  updateExercise(data: ExerciseUpdateInput!, where: ExerciseWhereUniqueInput!): Exercise
  updateManyExercises(data: ExerciseUpdateManyMutationInput!, where: ExerciseWhereInput): BatchPayload!
  upsertExercise(where: ExerciseWhereUniqueInput!, create: ExerciseCreateInput!, update: ExerciseUpdateInput!): Exercise!
  deleteExercise(where: ExerciseWhereUniqueInput!): Exercise
  deleteManyExercises(where: ExerciseWhereInput): BatchPayload!
  createExerciseParameter(data: ExerciseParameterCreateInput!): ExerciseParameter!
  updateExerciseParameter(data: ExerciseParameterUpdateInput!, where: ExerciseParameterWhereUniqueInput!): ExerciseParameter
  updateManyExerciseParameters(data: ExerciseParameterUpdateManyMutationInput!, where: ExerciseParameterWhereInput): BatchPayload!
  upsertExerciseParameter(where: ExerciseParameterWhereUniqueInput!, create: ExerciseParameterCreateInput!, update: ExerciseParameterUpdateInput!): ExerciseParameter!
  deleteExerciseParameter(where: ExerciseParameterWhereUniqueInput!): ExerciseParameter
  deleteManyExerciseParameters(where: ExerciseParameterWhereInput): BatchPayload!
  createExerciseRoutine(data: ExerciseRoutineCreateInput!): ExerciseRoutine!
  updateExerciseRoutine(data: ExerciseRoutineUpdateInput!, where: ExerciseRoutineWhereUniqueInput!): ExerciseRoutine
  updateManyExerciseRoutines(data: ExerciseRoutineUpdateManyMutationInput!, where: ExerciseRoutineWhereInput): BatchPayload!
  upsertExerciseRoutine(where: ExerciseRoutineWhereUniqueInput!, create: ExerciseRoutineCreateInput!, update: ExerciseRoutineUpdateInput!): ExerciseRoutine!
  deleteExerciseRoutine(where: ExerciseRoutineWhereUniqueInput!): ExerciseRoutine
  deleteManyExerciseRoutines(where: ExerciseRoutineWhereInput): BatchPayload!
  createExerciseType(data: ExerciseTypeCreateInput!): ExerciseType!
  updateExerciseType(data: ExerciseTypeUpdateInput!, where: ExerciseTypeWhereUniqueInput!): ExerciseType
  updateManyExerciseTypes(data: ExerciseTypeUpdateManyMutationInput!, where: ExerciseTypeWhereInput): BatchPayload!
  upsertExerciseType(where: ExerciseTypeWhereUniqueInput!, create: ExerciseTypeCreateInput!, update: ExerciseTypeUpdateInput!): ExerciseType!
  deleteExerciseType(where: ExerciseTypeWhereUniqueInput!): ExerciseType
  deleteManyExerciseTypes(where: ExerciseTypeWhereInput): BatchPayload!
  createMeasurement(data: MeasurementCreateInput!): Measurement!
  updateMeasurement(data: MeasurementUpdateInput!, where: MeasurementWhereUniqueInput!): Measurement
  updateManyMeasurements(data: MeasurementUpdateManyMutationInput!, where: MeasurementWhereInput): BatchPayload!
  upsertMeasurement(where: MeasurementWhereUniqueInput!, create: MeasurementCreateInput!, update: MeasurementUpdateInput!): Measurement!
  deleteMeasurement(where: MeasurementWhereUniqueInput!): Measurement
  deleteManyMeasurements(where: MeasurementWhereInput): BatchPayload!
  createRoutine(data: RoutineCreateInput!): Routine!
  updateRoutine(data: RoutineUpdateInput!, where: RoutineWhereUniqueInput!): Routine
  updateManyRoutines(data: RoutineUpdateManyMutationInput!, where: RoutineWhereInput): BatchPayload!
  upsertRoutine(where: RoutineWhereUniqueInput!, create: RoutineCreateInput!, update: RoutineUpdateInput!): Routine!
  deleteRoutine(where: RoutineWhereUniqueInput!): Routine
  deleteManyRoutines(where: RoutineWhereInput): BatchPayload!
  createRoutineWorkoutPlan(data: RoutineWorkoutPlanCreateInput!): RoutineWorkoutPlan!
  updateRoutineWorkoutPlan(data: RoutineWorkoutPlanUpdateInput!, where: RoutineWorkoutPlanWhereUniqueInput!): RoutineWorkoutPlan
  updateManyRoutineWorkoutPlans(data: RoutineWorkoutPlanUpdateManyMutationInput!, where: RoutineWorkoutPlanWhereInput): BatchPayload!
  upsertRoutineWorkoutPlan(where: RoutineWorkoutPlanWhereUniqueInput!, create: RoutineWorkoutPlanCreateInput!, update: RoutineWorkoutPlanUpdateInput!): RoutineWorkoutPlan!
  deleteRoutineWorkoutPlan(where: RoutineWorkoutPlanWhereUniqueInput!): RoutineWorkoutPlan
  deleteManyRoutineWorkoutPlans(where: RoutineWorkoutPlanWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserMeasurement(data: UserMeasurementCreateInput!): UserMeasurement!
  updateUserMeasurement(data: UserMeasurementUpdateInput!, where: UserMeasurementWhereUniqueInput!): UserMeasurement
  updateManyUserMeasurements(data: UserMeasurementUpdateManyMutationInput!, where: UserMeasurementWhereInput): BatchPayload!
  upsertUserMeasurement(where: UserMeasurementWhereUniqueInput!, create: UserMeasurementCreateInput!, update: UserMeasurementUpdateInput!): UserMeasurement!
  deleteUserMeasurement(where: UserMeasurementWhereUniqueInput!): UserMeasurement
  deleteManyUserMeasurements(where: UserMeasurementWhereInput): BatchPayload!
  createWorkout(data: WorkoutCreateInput!): Workout!
  updateWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateManyWorkouts(data: WorkoutUpdateManyMutationInput!, where: WorkoutWhereInput): BatchPayload!
  upsertWorkout(where: WorkoutWhereUniqueInput!, create: WorkoutCreateInput!, update: WorkoutUpdateInput!): Workout!
  deleteWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteManyWorkouts(where: WorkoutWhereInput): BatchPayload!
  createWorkoutExercise(data: WorkoutExerciseCreateInput!): WorkoutExercise!
  updateWorkoutExercise(data: WorkoutExerciseUpdateInput!, where: WorkoutExerciseWhereUniqueInput!): WorkoutExercise
  upsertWorkoutExercise(where: WorkoutExerciseWhereUniqueInput!, create: WorkoutExerciseCreateInput!, update: WorkoutExerciseUpdateInput!): WorkoutExercise!
  deleteWorkoutExercise(where: WorkoutExerciseWhereUniqueInput!): WorkoutExercise
  deleteManyWorkoutExercises(where: WorkoutExerciseWhereInput): BatchPayload!
  createWorkoutParameter(data: WorkoutParameterCreateInput!): WorkoutParameter!
  updateWorkoutParameter(data: WorkoutParameterUpdateInput!, where: WorkoutParameterWhereUniqueInput!): WorkoutParameter
  updateManyWorkoutParameters(data: WorkoutParameterUpdateManyMutationInput!, where: WorkoutParameterWhereInput): BatchPayload!
  upsertWorkoutParameter(where: WorkoutParameterWhereUniqueInput!, create: WorkoutParameterCreateInput!, update: WorkoutParameterUpdateInput!): WorkoutParameter!
  deleteWorkoutParameter(where: WorkoutParameterWhereUniqueInput!): WorkoutParameter
  deleteManyWorkoutParameters(where: WorkoutParameterWhereInput): BatchPayload!
  createWorkoutPlan(data: WorkoutPlanCreateInput!): WorkoutPlan!
  updateWorkoutPlan(data: WorkoutPlanUpdateInput!, where: WorkoutPlanWhereUniqueInput!): WorkoutPlan
  updateManyWorkoutPlans(data: WorkoutPlanUpdateManyMutationInput!, where: WorkoutPlanWhereInput): BatchPayload!
  upsertWorkoutPlan(where: WorkoutPlanWhereUniqueInput!, create: WorkoutPlanCreateInput!, update: WorkoutPlanUpdateInput!): WorkoutPlan!
  deleteWorkoutPlan(where: WorkoutPlanWhereUniqueInput!): WorkoutPlan
  deleteManyWorkoutPlans(where: WorkoutPlanWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  dailyExercise(where: DailyExerciseWhereUniqueInput!): DailyExercise
  dailyExercises(where: DailyExerciseWhereInput, orderBy: DailyExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DailyExercise]!
  dailyExercisesConnection(where: DailyExerciseWhereInput, orderBy: DailyExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DailyExerciseConnection!
  exercise(where: ExerciseWhereUniqueInput!): Exercise
  exercises(where: ExerciseWhereInput, orderBy: ExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exercise]!
  exercisesConnection(where: ExerciseWhereInput, orderBy: ExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExerciseConnection!
  exerciseParameter(where: ExerciseParameterWhereUniqueInput!): ExerciseParameter
  exerciseParameters(where: ExerciseParameterWhereInput, orderBy: ExerciseParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExerciseParameter]!
  exerciseParametersConnection(where: ExerciseParameterWhereInput, orderBy: ExerciseParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExerciseParameterConnection!
  exerciseRoutine(where: ExerciseRoutineWhereUniqueInput!): ExerciseRoutine
  exerciseRoutines(where: ExerciseRoutineWhereInput, orderBy: ExerciseRoutineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExerciseRoutine]!
  exerciseRoutinesConnection(where: ExerciseRoutineWhereInput, orderBy: ExerciseRoutineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExerciseRoutineConnection!
  exerciseType(where: ExerciseTypeWhereUniqueInput!): ExerciseType
  exerciseTypes(where: ExerciseTypeWhereInput, orderBy: ExerciseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExerciseType]!
  exerciseTypesConnection(where: ExerciseTypeWhereInput, orderBy: ExerciseTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExerciseTypeConnection!
  measurement(where: MeasurementWhereUniqueInput!): Measurement
  measurements(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Measurement]!
  measurementsConnection(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementConnection!
  routine(where: RoutineWhereUniqueInput!): Routine
  routines(where: RoutineWhereInput, orderBy: RoutineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Routine]!
  routinesConnection(where: RoutineWhereInput, orderBy: RoutineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoutineConnection!
  routineWorkoutPlan(where: RoutineWorkoutPlanWhereUniqueInput!): RoutineWorkoutPlan
  routineWorkoutPlans(where: RoutineWorkoutPlanWhereInput, orderBy: RoutineWorkoutPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoutineWorkoutPlan]!
  routineWorkoutPlansConnection(where: RoutineWorkoutPlanWhereInput, orderBy: RoutineWorkoutPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoutineWorkoutPlanConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userMeasurement(where: UserMeasurementWhereUniqueInput!): UserMeasurement
  userMeasurements(where: UserMeasurementWhereInput, orderBy: UserMeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserMeasurement]!
  userMeasurementsConnection(where: UserMeasurementWhereInput, orderBy: UserMeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserMeasurementConnection!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout]!
  workoutsConnection(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutConnection!
  workoutExercise(where: WorkoutExerciseWhereUniqueInput!): WorkoutExercise
  workoutExercises(where: WorkoutExerciseWhereInput, orderBy: WorkoutExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutExercise]!
  workoutExercisesConnection(where: WorkoutExerciseWhereInput, orderBy: WorkoutExerciseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutExerciseConnection!
  workoutParameter(where: WorkoutParameterWhereUniqueInput!): WorkoutParameter
  workoutParameters(where: WorkoutParameterWhereInput, orderBy: WorkoutParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutParameter]!
  workoutParametersConnection(where: WorkoutParameterWhereInput, orderBy: WorkoutParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutParameterConnection!
  workoutPlan(where: WorkoutPlanWhereUniqueInput!): WorkoutPlan
  workoutPlans(where: WorkoutPlanWhereInput, orderBy: WorkoutPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutPlan]!
  workoutPlansConnection(where: WorkoutPlanWhereInput, orderBy: WorkoutPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutPlanConnection!
  node(id: ID!): Node
}

type Routine {
  id: ID!
  name: String!
}

type RoutineConnection {
  pageInfo: PageInfo!
  edges: [RoutineEdge]!
  aggregate: AggregateRoutine!
}

input RoutineCreateInput {
  id: ID
  name: String!
}

input RoutineCreateOneInput {
  create: RoutineCreateInput
  connect: RoutineWhereUniqueInput
}

type RoutineEdge {
  node: Routine!
  cursor: String!
}

enum RoutineOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RoutinePreviousValues {
  id: ID!
  name: String!
}

type RoutineSubscriptionPayload {
  mutation: MutationType!
  node: Routine
  updatedFields: [String!]
  previousValues: RoutinePreviousValues
}

input RoutineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoutineWhereInput
  AND: [RoutineSubscriptionWhereInput!]
  OR: [RoutineSubscriptionWhereInput!]
  NOT: [RoutineSubscriptionWhereInput!]
}

input RoutineUpdateDataInput {
  name: String
}

input RoutineUpdateInput {
  name: String
}

input RoutineUpdateManyMutationInput {
  name: String
}

input RoutineUpdateOneRequiredInput {
  create: RoutineCreateInput
  update: RoutineUpdateDataInput
  upsert: RoutineUpsertNestedInput
  connect: RoutineWhereUniqueInput
}

input RoutineUpsertNestedInput {
  update: RoutineUpdateDataInput!
  create: RoutineCreateInput!
}

input RoutineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RoutineWhereInput!]
  OR: [RoutineWhereInput!]
  NOT: [RoutineWhereInput!]
}

input RoutineWhereUniqueInput {
  id: ID
}

type RoutineWorkoutPlan {
  id: ID!
  order: Int!
  routine: Routine!
  plan: WorkoutPlan!
}

type RoutineWorkoutPlanConnection {
  pageInfo: PageInfo!
  edges: [RoutineWorkoutPlanEdge]!
  aggregate: AggregateRoutineWorkoutPlan!
}

input RoutineWorkoutPlanCreateInput {
  id: ID
  order: Int!
  routine: RoutineCreateOneInput!
  plan: WorkoutPlanCreateOneInput!
}

type RoutineWorkoutPlanEdge {
  node: RoutineWorkoutPlan!
  cursor: String!
}

enum RoutineWorkoutPlanOrderByInput {
  id_ASC
  id_DESC
  order_ASC
  order_DESC
}

type RoutineWorkoutPlanPreviousValues {
  id: ID!
  order: Int!
}

type RoutineWorkoutPlanSubscriptionPayload {
  mutation: MutationType!
  node: RoutineWorkoutPlan
  updatedFields: [String!]
  previousValues: RoutineWorkoutPlanPreviousValues
}

input RoutineWorkoutPlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoutineWorkoutPlanWhereInput
  AND: [RoutineWorkoutPlanSubscriptionWhereInput!]
  OR: [RoutineWorkoutPlanSubscriptionWhereInput!]
  NOT: [RoutineWorkoutPlanSubscriptionWhereInput!]
}

input RoutineWorkoutPlanUpdateInput {
  order: Int
  routine: RoutineUpdateOneRequiredInput
  plan: WorkoutPlanUpdateOneRequiredInput
}

input RoutineWorkoutPlanUpdateManyMutationInput {
  order: Int
}

input RoutineWorkoutPlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  routine: RoutineWhereInput
  plan: WorkoutPlanWhereInput
  AND: [RoutineWorkoutPlanWhereInput!]
  OR: [RoutineWorkoutPlanWhereInput!]
  NOT: [RoutineWorkoutPlanWhereInput!]
}

input RoutineWorkoutPlanWhereUniqueInput {
  id: ID
}

type Subscription {
  dailyExercise(where: DailyExerciseSubscriptionWhereInput): DailyExerciseSubscriptionPayload
  exercise(where: ExerciseSubscriptionWhereInput): ExerciseSubscriptionPayload
  exerciseParameter(where: ExerciseParameterSubscriptionWhereInput): ExerciseParameterSubscriptionPayload
  exerciseRoutine(where: ExerciseRoutineSubscriptionWhereInput): ExerciseRoutineSubscriptionPayload
  exerciseType(where: ExerciseTypeSubscriptionWhereInput): ExerciseTypeSubscriptionPayload
  measurement(where: MeasurementSubscriptionWhereInput): MeasurementSubscriptionPayload
  routine(where: RoutineSubscriptionWhereInput): RoutineSubscriptionPayload
  routineWorkoutPlan(where: RoutineWorkoutPlanSubscriptionWhereInput): RoutineWorkoutPlanSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userMeasurement(where: UserMeasurementSubscriptionWhereInput): UserMeasurementSubscriptionPayload
  workout(where: WorkoutSubscriptionWhereInput): WorkoutSubscriptionPayload
  workoutExercise(where: WorkoutExerciseSubscriptionWhereInput): WorkoutExerciseSubscriptionPayload
  workoutParameter(where: WorkoutParameterSubscriptionWhereInput): WorkoutParameterSubscriptionPayload
  workoutPlan(where: WorkoutPlanSubscriptionWhereInput): WorkoutPlanSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

type UserMeasurement {
  id: ID!
  user: User!
  measurement: Measurement!
  date: DateTime!
  value: Float!
}

type UserMeasurementConnection {
  pageInfo: PageInfo!
  edges: [UserMeasurementEdge]!
  aggregate: AggregateUserMeasurement!
}

input UserMeasurementCreateInput {
  id: ID
  user: UserCreateOneInput!
  measurement: MeasurementCreateOneInput!
  date: DateTime!
  value: Float!
}

type UserMeasurementEdge {
  node: UserMeasurement!
  cursor: String!
}

enum UserMeasurementOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  value_ASC
  value_DESC
}

type UserMeasurementPreviousValues {
  id: ID!
  date: DateTime!
  value: Float!
}

type UserMeasurementSubscriptionPayload {
  mutation: MutationType!
  node: UserMeasurement
  updatedFields: [String!]
  previousValues: UserMeasurementPreviousValues
}

input UserMeasurementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserMeasurementWhereInput
  AND: [UserMeasurementSubscriptionWhereInput!]
  OR: [UserMeasurementSubscriptionWhereInput!]
  NOT: [UserMeasurementSubscriptionWhereInput!]
}

input UserMeasurementUpdateInput {
  user: UserUpdateOneRequiredInput
  measurement: MeasurementUpdateOneRequiredInput
  date: DateTime
  value: Float
}

input UserMeasurementUpdateManyMutationInput {
  date: DateTime
  value: Float
}

input UserMeasurementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  measurement: MeasurementWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  AND: [UserMeasurementWhereInput!]
  OR: [UserMeasurementWhereInput!]
  NOT: [UserMeasurementWhereInput!]
}

input UserMeasurementWhereUniqueInput {
  id: ID
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Workout {
  id: ID!
  user: User!
  date: DateTime!
  plan: WorkoutPlan!
  routine: Routine!
}

type WorkoutConnection {
  pageInfo: PageInfo!
  edges: [WorkoutEdge]!
  aggregate: AggregateWorkout!
}

input WorkoutCreateInput {
  id: ID
  user: UserCreateOneInput!
  date: DateTime!
  plan: WorkoutPlanCreateOneInput!
  routine: RoutineCreateOneInput!
}

input WorkoutCreateOneInput {
  create: WorkoutCreateInput
  connect: WorkoutWhereUniqueInput
}

type WorkoutEdge {
  node: Workout!
  cursor: String!
}

type WorkoutExercise {
  id: ID!
  workout: Workout!
  exercise: Exercise!
  parameters(where: WorkoutParameterWhereInput, orderBy: WorkoutParameterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutParameter!]
}

type WorkoutExerciseConnection {
  pageInfo: PageInfo!
  edges: [WorkoutExerciseEdge]!
  aggregate: AggregateWorkoutExercise!
}

input WorkoutExerciseCreateInput {
  id: ID
  workout: WorkoutCreateOneInput!
  exercise: ExerciseCreateOneInput!
  parameters: WorkoutParameterCreateManyInput
}

type WorkoutExerciseEdge {
  node: WorkoutExercise!
  cursor: String!
}

enum WorkoutExerciseOrderByInput {
  id_ASC
  id_DESC
}

type WorkoutExercisePreviousValues {
  id: ID!
}

type WorkoutExerciseSubscriptionPayload {
  mutation: MutationType!
  node: WorkoutExercise
  updatedFields: [String!]
  previousValues: WorkoutExercisePreviousValues
}

input WorkoutExerciseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutExerciseWhereInput
  AND: [WorkoutExerciseSubscriptionWhereInput!]
  OR: [WorkoutExerciseSubscriptionWhereInput!]
  NOT: [WorkoutExerciseSubscriptionWhereInput!]
}

input WorkoutExerciseUpdateInput {
  workout: WorkoutUpdateOneRequiredInput
  exercise: ExerciseUpdateOneRequiredInput
  parameters: WorkoutParameterUpdateManyInput
}

input WorkoutExerciseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workout: WorkoutWhereInput
  exercise: ExerciseWhereInput
  parameters_every: WorkoutParameterWhereInput
  parameters_some: WorkoutParameterWhereInput
  parameters_none: WorkoutParameterWhereInput
  AND: [WorkoutExerciseWhereInput!]
  OR: [WorkoutExerciseWhereInput!]
  NOT: [WorkoutExerciseWhereInput!]
}

input WorkoutExerciseWhereUniqueInput {
  id: ID
}

enum WorkoutOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
}

type WorkoutParameter {
  id: ID!
  parameter: ExerciseParameter!
  value: Float
}

type WorkoutParameterConnection {
  pageInfo: PageInfo!
  edges: [WorkoutParameterEdge]!
  aggregate: AggregateWorkoutParameter!
}

input WorkoutParameterCreateInput {
  id: ID
  parameter: ExerciseParameterCreateOneInput!
  value: Float
}

input WorkoutParameterCreateManyInput {
  create: [WorkoutParameterCreateInput!]
  connect: [WorkoutParameterWhereUniqueInput!]
}

type WorkoutParameterEdge {
  node: WorkoutParameter!
  cursor: String!
}

enum WorkoutParameterOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
}

type WorkoutParameterPreviousValues {
  id: ID!
  value: Float
}

input WorkoutParameterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  AND: [WorkoutParameterScalarWhereInput!]
  OR: [WorkoutParameterScalarWhereInput!]
  NOT: [WorkoutParameterScalarWhereInput!]
}

type WorkoutParameterSubscriptionPayload {
  mutation: MutationType!
  node: WorkoutParameter
  updatedFields: [String!]
  previousValues: WorkoutParameterPreviousValues
}

input WorkoutParameterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutParameterWhereInput
  AND: [WorkoutParameterSubscriptionWhereInput!]
  OR: [WorkoutParameterSubscriptionWhereInput!]
  NOT: [WorkoutParameterSubscriptionWhereInput!]
}

input WorkoutParameterUpdateDataInput {
  parameter: ExerciseParameterUpdateOneRequiredInput
  value: Float
}

input WorkoutParameterUpdateInput {
  parameter: ExerciseParameterUpdateOneRequiredInput
  value: Float
}

input WorkoutParameterUpdateManyDataInput {
  value: Float
}

input WorkoutParameterUpdateManyInput {
  create: [WorkoutParameterCreateInput!]
  update: [WorkoutParameterUpdateWithWhereUniqueNestedInput!]
  upsert: [WorkoutParameterUpsertWithWhereUniqueNestedInput!]
  delete: [WorkoutParameterWhereUniqueInput!]
  connect: [WorkoutParameterWhereUniqueInput!]
  set: [WorkoutParameterWhereUniqueInput!]
  disconnect: [WorkoutParameterWhereUniqueInput!]
  deleteMany: [WorkoutParameterScalarWhereInput!]
  updateMany: [WorkoutParameterUpdateManyWithWhereNestedInput!]
}

input WorkoutParameterUpdateManyMutationInput {
  value: Float
}

input WorkoutParameterUpdateManyWithWhereNestedInput {
  where: WorkoutParameterScalarWhereInput!
  data: WorkoutParameterUpdateManyDataInput!
}

input WorkoutParameterUpdateWithWhereUniqueNestedInput {
  where: WorkoutParameterWhereUniqueInput!
  data: WorkoutParameterUpdateDataInput!
}

input WorkoutParameterUpsertWithWhereUniqueNestedInput {
  where: WorkoutParameterWhereUniqueInput!
  update: WorkoutParameterUpdateDataInput!
  create: WorkoutParameterCreateInput!
}

input WorkoutParameterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parameter: ExerciseParameterWhereInput
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  AND: [WorkoutParameterWhereInput!]
  OR: [WorkoutParameterWhereInput!]
  NOT: [WorkoutParameterWhereInput!]
}

input WorkoutParameterWhereUniqueInput {
  id: ID
}

type WorkoutPlan {
  id: ID!
  name: String!
  description: String
}

type WorkoutPlanConnection {
  pageInfo: PageInfo!
  edges: [WorkoutPlanEdge]!
  aggregate: AggregateWorkoutPlan!
}

input WorkoutPlanCreateInput {
  id: ID
  name: String!
  description: String
}

input WorkoutPlanCreateOneInput {
  create: WorkoutPlanCreateInput
  connect: WorkoutPlanWhereUniqueInput
}

type WorkoutPlanEdge {
  node: WorkoutPlan!
  cursor: String!
}

enum WorkoutPlanOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
}

type WorkoutPlanPreviousValues {
  id: ID!
  name: String!
  description: String
}

type WorkoutPlanSubscriptionPayload {
  mutation: MutationType!
  node: WorkoutPlan
  updatedFields: [String!]
  previousValues: WorkoutPlanPreviousValues
}

input WorkoutPlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutPlanWhereInput
  AND: [WorkoutPlanSubscriptionWhereInput!]
  OR: [WorkoutPlanSubscriptionWhereInput!]
  NOT: [WorkoutPlanSubscriptionWhereInput!]
}

input WorkoutPlanUpdateDataInput {
  name: String
  description: String
}

input WorkoutPlanUpdateInput {
  name: String
  description: String
}

input WorkoutPlanUpdateManyMutationInput {
  name: String
  description: String
}

input WorkoutPlanUpdateOneRequiredInput {
  create: WorkoutPlanCreateInput
  update: WorkoutPlanUpdateDataInput
  upsert: WorkoutPlanUpsertNestedInput
  connect: WorkoutPlanWhereUniqueInput
}

input WorkoutPlanUpsertNestedInput {
  update: WorkoutPlanUpdateDataInput!
  create: WorkoutPlanCreateInput!
}

input WorkoutPlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [WorkoutPlanWhereInput!]
  OR: [WorkoutPlanWhereInput!]
  NOT: [WorkoutPlanWhereInput!]
}

input WorkoutPlanWhereUniqueInput {
  id: ID
}

type WorkoutPreviousValues {
  id: ID!
  date: DateTime!
}

type WorkoutSubscriptionPayload {
  mutation: MutationType!
  node: Workout
  updatedFields: [String!]
  previousValues: WorkoutPreviousValues
}

input WorkoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutWhereInput
  AND: [WorkoutSubscriptionWhereInput!]
  OR: [WorkoutSubscriptionWhereInput!]
  NOT: [WorkoutSubscriptionWhereInput!]
}

input WorkoutUpdateDataInput {
  user: UserUpdateOneRequiredInput
  date: DateTime
  plan: WorkoutPlanUpdateOneRequiredInput
  routine: RoutineUpdateOneRequiredInput
}

input WorkoutUpdateInput {
  user: UserUpdateOneRequiredInput
  date: DateTime
  plan: WorkoutPlanUpdateOneRequiredInput
  routine: RoutineUpdateOneRequiredInput
}

input WorkoutUpdateManyMutationInput {
  date: DateTime
}

input WorkoutUpdateOneRequiredInput {
  create: WorkoutCreateInput
  update: WorkoutUpdateDataInput
  upsert: WorkoutUpsertNestedInput
  connect: WorkoutWhereUniqueInput
}

input WorkoutUpsertNestedInput {
  update: WorkoutUpdateDataInput!
  create: WorkoutCreateInput!
}

input WorkoutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  plan: WorkoutPlanWhereInput
  routine: RoutineWhereInput
  AND: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  NOT: [WorkoutWhereInput!]
}

input WorkoutWhereUniqueInput {
  id: ID
}
`
      }
    